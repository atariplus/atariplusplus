<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sun Dec 25 10:56:01 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>atari++</title>

</head>
<body>

<h1 align="center">atari++</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#CONFIGURATION FILES">CONFIGURATION FILES</a><br>
<a href="#KEYMAP">KEYMAP</a><br>
<a href="#THE CURSES EMULATION">THE CURSES EMULATION</a><br>
<a href="#SNAPSHOT FILES">SNAPSHOT FILES</a><br>
<a href="#THE H: HANDLER">THE H: HANDLER</a><br>
<a href="#THE E: HANDLER">THE E: HANDLER</a><br>
<a href="#THE R: HANDLER">THE R: HANDLER</a><br>
<a href="#THE OS ROM EMULATION">THE OS ROM EMULATION</a><br>
<a href="#THE D: HANDLER">THE D: HANDLER</a><br>
<a href="#THE BASIC EMULATION">THE BASIC EMULATION</a><br>
<a href="#THE BUILT-IN MONITOR">THE BUILT-IN MONITOR</a><br>
<a href="#FILES">FILES</a><br>
<a href="#ENVIRONMENT VARIABLES">ENVIRONMENT VARIABLES</a><br>
<a href="#CREDITS">CREDITS</a><br>
<a href="#REFERENCES">REFERENCES</a><br>
<a href="#AUTHOR">AUTHOR</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">atari++ - a
versatile extended emulator of Atari 8 bit machines</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>atari++</b>
[-option value [-option value]...]</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><i>atari++</i>
is an emulator for (now rather aged) Atari 8 bit computers.
It emulates the Atari800, Atari400, the 800XL and 600XL, the
65XE and 130XE and the Atari 5200 Game Console. The
emulation is cycle-precise, that is &ldquo;on the fly&rdquo;
modifications of chip registers will be visible on the
screen immediately, emulating even programs using horizontal
kernel tricks correctly.</p>

<p style="margin-left:11%; margin-top: 1em"><i>atari++</i>
includes also emulation of various disk drive models,
capable of single, enhanced and double density and adds some
frequent extensions found in third-party hardware. The disk
drive emulation supports disk images in the <i>xfd</i> and
<i>atr</i> file format, and is also capable of loading
binary load files (so called <i>exe</i> files) by emulating
a mini Game-DOS whose disk layout is similar to Dos 2.0S.
Most <i>exe</i> files wouldn&rsquo;t require to be loaded
from a regular DOS therefore. As a bonus, the emulation also
includes Matthias Reichl&rsquo;s &ldquo;atarisio&rdquo;
interface, allowing you to connect a real 1050 or 810 drive
to the emulating PC by means of a 1050-to-PC or ProSystem
cable.</p>

<p style="margin-left:11%; margin-top: 1em">In case no
Atari ROM image is available, <i>atari++</i> emulates a
800XL/130XE ROM image compatible to the Atari ROM that is
sufficient to run almost all programs. Basic programs are
supported by the built-in Basic emulation that is also
compatible to the native Basic ROM.</p>

<p style="margin-left:11%; margin-top: 1em">Emulation of
printers is included as well. Print-out text is forwarded to
the standard printer tool, which defaults to the <i>lpr</i>
printer front-end. The print-out command can be adjusted by
means of the command line options and the configuration
files (see below).</p>

<p style="margin-left:11%; margin-top: 1em">Additional
features include emulation of the 850 serial/parallel
interface box, emulation of the tape drive, a
screen-snapshot, a complete machine state save and load
feature that allows you to stop and replay a game in a later
session and sound support by the <i>Open Sound System</i>
(Oss) or <i>Alsa</i> sound drivers.</p>

<p style="margin-left:11%; margin-top: 1em">Furthermore, to
aid the developer, a simple system monitor using a
<i>curses</i> terminal front-end has been integrated into
the emulator. It offers several features not available on
the real hardware, as single stepping thru programs and
setting breakpoints, even in ROM code.</p>

<p style="margin-left:11%; margin-top: 1em">Graphics output
is either emulated within an <i>X11</i> window, or - if
available - with the <i>SDL</i> library. As last resort, and
for special applications, some ports provide a <i>curses</i>
front-end that renders its output in textual form on a
console. Alternatively, the emulator can also be instructed
to read and write input to the operating system editor
device directly to and from the console, i.e. the standard
input and output streams of the program. This is not
implemented as a new type of front-end, but rather as an
operating system patch.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Quite untypical
for unixoid systems, the <i>atari++</i> options are not case
sensitive, upper and lower case won&rsquo;t matter.
Furthermore, the order of the command line arguments
doesn&rsquo;t matter as well. The following options are
supported:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>--help</p></td>
<td width="2%"></td>
<td width="78%">


<p>prints all available options to the console.
<b>NOTE:</b> Due to the dynamic build-up of the
<i>atari++</i> components, the options these components
become only available if the corresponding component is
activated as well. E.g, you won&rsquo;t see the X11 options
with the SDL front-end activated.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>-h</p></td>
<td width="2%"></td>
<td width="78%">


<p>similar to the above.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">All following
options are of four kinds: <b>Numerical</b> options taking
exactly one number as argument. They typically accept only
numbers within a limited range. <b>Boolean</b> options,
taking the strings <b>on yes</b> or <b>true</b> as positive
and <b>off</b> , <b>no</b> or <b>false</b> as negative
choices and <b>string</b> options that take either a file or
a string as value. Last but not least, <b>selective</b>
options that pick one out of several possible, mutually
exclusive choices.</p>

<p style="margin-left:11%; margin-top: 1em"><b>On the Fly
Configuration</b> <br>
Atari++ provides a quick and a complete menu to setup or
modify its configuration on the fly. For the quick menu,
press and hold the left mouse button within the emulator
window, and pick an apropriate option from the menu on the
screen. This menu provides the most-used options, namely to
load and boot a disk, to pick a cartridge or to reset the
emulated Atari.</p>

<p style="margin-left:11%; margin-top: 1em">The full menu
is either available as an option within the quick menu, or
by pressing the <b>F1</b> key on the keyboard. The options
presented there are identical to the options listed
below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b>
The quick menu is not available in case the mouse has been
arbitrated to emulate a joystick or any other kind of input
device. You&rsquo;d need to enter the full menu by the
<b>F1</b> key to adjust the configuration in this case.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Global
Options</b> <br>
This set of options does not belong to a specific part of
the emulation core, but rather influence the emulator as a
whole. <br>
-h or --help</p>

<p style="margin-left:22%;">prints out the list of
currently available options. This list does, however, depend
on the current configuration of the file as options for
modules that are currently not in use will not be shown on
this list. For example, if your <b>.atari++.conf</b> file
selects the <i>X11</i> frontend for graphics output, the
options for the <i>SDL</i> graphics support will not be
shown. Unlike all other options, this option does not take
an argument.</p>

<p style="margin-left:11%;">-config filename</p>

<p style="margin-left:22%;">Load an alternative
configuration file into the emulator. This will override the
options from all other configuration files, but will be
overridden by the command line arguments itself.</p>

<p style="margin-left:11%;">-state filename</p>

<p style="margin-left:22%;">Load a machine state snapshot
file. This restores the machine state of a previous
<i>atari++</i> session by re-installing the memory conents
and all hardware register settings of the previous session.
For more details about the snapshot feature, see the
<b>SNAPSHOT FILES</b> section below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Machine Type
Options</b> <br>
The following options modify the overall emulation process,
picks the hardware to be emulated and the frontend how to
perform graphics and sound output. <br>
-machine 800|1200|XL|XE|5200</p>

<p style="margin-left:22%;">Sets the type of machine to
emulate. This is a meta-option that sets suitable defaults
for several other options, still allowing to override these
defaults with further commands. Hence, you&rsquo;d be still
able to run an Atari XL machine with the Os of the Atari
800. The following models are available: <b>800</b> emulates
the Atari 800 and its derivative, the Atari 400. <b>1200</b>
emulates the Atari 1200XL. This is almost identical to the
800XL, except that the default ROM image is different.
<b>XL</b> emulates the Atari 800XL, the 600XL and the 65XE.
<b>XE</b> emulates the Atari 130XE with a total of 128KByte
memory. Last but not least, the <b>5200</b> argument selects
the emulation of the 5200 game console.</p>

<p style="margin-left:11%;">-frontend
X11|SDL|CURSES|NONE</p>

<p style="margin-left:22%;">Defines which graphical
front-end should be used. Currently, the <b>X11</b> the
<b>CURSES</b> and the <b>SDL</b> front-ends are supported.
<b>NONE</b> is a dummy front-end without any graphical or
textual output that can be used for playing music or related
tasks. The <b>installedevice</b> option is suggested to get
minimal support from the console using only stream-I/O. Note
this type of redirection is not a front-end option, but
rather an optional operating system patch, see <b>OS
Options</b> below.</p>

<p style="margin-left:22%; margin-top: 1em">The X11
interface is only available for Unix based operating
systems, most notably Linux, while the SDL interface is
currently available on most ports. The latter is also able
to run in a full-screen mode that is more suitable for
gameplay. Typically, the SDL front-end provides better
performance unless you need to scale up the output with the
-pixelwidth or -pixelheight options. Then, X11 performs
noticeably better. The CURSES front-end requires only a
terminal for rendering, but its graphics capabilities are
rather limited. Specifically, it is only able to emulate
text-based graphics modes and expects the built-in font to
render the output. The keyboard mapping for the CURSES
output is also slightly different, see the CURSES section
for details.</p>

<p style="margin-left:11%;">-sound
HQOSS|OSS|WAV|SDL|ALSA|DIRECTX</p>

<p style="margin-left:22%;">Sets the audio front-end used
to generate audio output. For the <b>OSS</b> and
<b>HQOSS</b> front-ends, an <i>Open Sound System</i>
compatible driver is required, or no sound whatsoever will
be available. Sound synthesis will be very close to the real
sound output and will be at good quality, though some CPU
power is required to guarantee continuous output without
dropouts. In general, the <b>HQOSS</b> driver is preferably
since it requires less precise implementations of the Oss
standard and provides excellent quality for synthesized
speech.</p>

<p style="margin-left:22%; margin-top: 1em">The main
intention of the <b>WAV</b> front-end is to record the sound
output as sampled sound in a <i>.wav</i> encoded file in
optimum quality. To allow you to listen to in-game sounds,
this front-end also offers a &ldquo;play-back&rdquo; option
that also generates sound output thru an OSS compatible
sound output, though this output is of less quality than
that of the dedicated <b>HQOSS</b> module. Even though the
play-back sound may contain some &ldquo;blips&rdquo; or
drop-outs, the quality of the recorded audio within the
<i>.wav</i> file will be perfect and very close to the
original.</p>

<p style="margin-left:22%; margin-top: 1em">The <b>SDL</b>
audio generation comes close in quality to that of the
<b>HQOSS</b> driver, though it is more likely to generate
drop-outs for highly loaded systems. SDL is the best in
portability as SDL exists on a variety of systems. The SDL
driver also emulates software speech correctly.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>DIRECTX</b> driver is obviously available only for win32
compilations and uses the DirectSound interface of the
DirectX system. This is the prefered sound system under
Windows as it offers lowest latency at best quality.</p>

<p style="margin-left:22%; margin-top: 1em">Finally, the
<b>ALSA</b> front-end uses the state of the art ALSA sound
drivers for linux and provides optimal sound quality at
minimal CPU load. It provides similar or better quality than
the <b>HQOSS</b> front-end at less complexity, but it
requires ALSA support, nowadays almost universally
available.</p>

<p style="margin-left:11%;">-monitoroncrash bool</p>

<p style="margin-left:22%;">If this boolean option is
enabled, then the emulator enters automatically the built-in
monitor in case the 6502 CPU crashes due to a corrupt
program. Note that these crashes are not due to bugs in the
emulator, but rather due to flaws in the emulated program,
i.e. a &ldquo;real&rdquo; Atari would have crashed in the
same situation. If this option is disabled, then a warning
gets printed and the user menu is entered. It is then up to
you to either reset the emulation or to launch the monitor
manually. This option defaults to <b>false</b> ,i.e. the
monitor is not entered by itself.</p>

<p style="margin-left:22%; margin-top: 1em">For details
about the system monitor, see the <b>MONITOR</b> section
below.</p>

<p style="margin-left:11%;">-acceptlicence bool</p>

<p style="margin-left:22%;">If enabled, then it is
understood that you read and agreed to the licence
conditions under which Atari++ is delivered, and the licence
conditions are no longer presented on startup.</p>

<p style="margin-left:11%;">-stereopokey bool</p>

<p style="margin-left:22%;">Toggles the &ldquo;dual
Pokey&rdquo; hardware hack emulation. This hardware hack
installs a second Pokey at base address $d210 into the
system, allowing stereo sound emulation. Atari++ provides
then a second Pokey chip named &ldquo;ExtraPokey&rdquo; that
otherwise takes the same configuration arguments than the
first Pokey does, though this second chip is not connected
to the serial output and the keyboard.</p>

<p style="margin-left:22%; margin-top: 1em"><b>NOTE:</b>
The second Pokey chip is fully functional and also provides
interrupts. Since the Atari Os is not aware of this chip, it
cannot handle these interrupts. Thus, programs might crash
if interrupts of this extra chip are erraneously enabled.
This is not the fault of the emulator, a real system would
crash under the same circumstances.</p>

<p style="margin-left:11%;">-ignoreerrors bool</p>

<p style="margin-left:22%;">instructs the emulator to
ignore all error messages and to continue operations as if
the error requester has been closed by pressing
&ldquo;Cancel&rdquo;.</p>

<p style="margin-left:11%;">-ignorewarnings bool</p>

<p style="margin-left:22%;">similar to the above option,
will suppress all warning requesters as if the user accepted
the warning.</p>

<p style="margin-left:11%; margin-top: 1em"><b>CPU
Options</b> <br>
The following options control the emulation of the 6502 CPU:
<br>
-traceonreset bool</p>

<p style="margin-left:22%;">This boolean option is useful
for debugging. If enabled with the <b>on</b> argument, the
CPU enters trace mode on a reset, entering the build-in
monitor immediately.</p>

<p style="margin-left:11%;">-traceinterrupts bool</p>

<p style="margin-left:22%;">Another debugging related
option. If this is enabled, instruction stepping will also
step into interrupt routines as soon as an interrupt gets
detected. This might cause some confusion because
surprisingly the 6502 CPU will continue execution from a
completely different place, though it is helpful to find
bugs in display list interrupts.</p>

<p style="margin-left:11%;">-cputype 6502|WD65C02</p>

<p style="margin-left:22%;">Selects the CPU type that is
emulated. The WD65C02 offers a couple of addtional
addressing modes and instructions that are supported by a
couple of products, e.g. the Mac/65 assembler cartridge.</p>

<p style="margin-left:11%; margin-top: 1em"><b>GTIA
Options</b> <br>
The following options modify the emulation process of the
video signal generator, the <i>Graphics Television Interface
Adaptor</i> chip: <br>
-videomode PAL|NTSC</p>

<p style="margin-left:22%;">Defines whether the emulated
GTIA should either identify itself as <b>PAL</b> or as
<b>NTSC</b> chip. Some games read this value and modify
their timing accordingly. This option also changes the color
map GTIA sends to the front-end as colors differ slightly
between the PAL and the NTSC version of GTIA.</p>

<p style="margin-left:11%;">-ChipGeneration
CTIA|GTIA|XLGTIA</p>

<p style="margin-left:22%;">Selects the chip generation to
emulate. <b>CTIA</b> selects the old first generation used
in some very early 800 and 400 models. This chip did not
provide the special 16 hue/16 luminance and 8 color modes,
BASIC modes 9 to 11. <b>GTIA</b> selects the second
generation, used in most 800 and 400 models, and
<b>XLGTIA</b> the third generation in the XL series. The
last two chips do actually not differ, only the surrounding
analog circuits change the color artifacts slightly, which
is the only noticable difference between them.</p>

<p style="margin-left:11%;">-artifacts bool</p>

<p style="margin-left:22%;">This boolean option controls
whether GTIA should emulate color artifacts that are caused
by video system. If set to <b>on</b> , the video rendering
will detect hi-lo and lo-hi transitions for high-resolution
graphics and text mode and will generate pseudo-colors
similar to a real TV. These artifacts are limited to NTSC
systems for the real hardware and are not as effective nor
very visible for the PAL hardware; the emulator, however,
displays them regardless of the emulated video mode. Some
games require this setting to look properly. If set to
<b>off</b> , artifact generation is disabled as for a higher
quality monitor or for the PAL video system. This also makes
text more readable and less blurry, it also speeds up the
emulation process somewhat and is better suited for
text-oriented software.</p>

<p style="margin-left:11%;">-palcolorblur bool</p>

<p style="margin-left:22%;">enables emulation of a feature
of the PAL video system standard that can be used to create
additional colors by mixing. If two adjacent horizontal
lines on top of each other share the same intensity but have
a different hue, then the mixture of the colors appears
instead of two separate colors. This option is
computationally a bit complex and requires a true color
display, i.e. a color depth of 24 bit to be effective.</p>

<p style="margin-left:11%;">-antiflicker bool</p>

<p style="margin-left:22%;">enables the Atari++ flicker
fixer. Some programs create additional colors by quickly
altering the colors forth and back, causing the mixture of
the colors due to the slowness of the TV screen. PC monitors
are typically much faster, causing an anoying flicker for
these programs. This switch enables a flicker-fixer that
mixes the colors already in the GTIA display generation at
the price of a higher complexity. This option also requires
a true-color display, i.e. a bit depth of 24 bit.</p>

<p style="margin-left:11%;">-playerpositiondelay 0..32</p>

<p style="margin-left:22%;">this setting controls the
number of half color-clocks required by GTIA to detect any
change of the player/missile horizontal position register.
It is the minimal screen distance in half color-clocks after
writing to the horizontal position register until the change
becomes effective. The default for this value is 12, i.e. it
takes 12/4 = 3 CPU clocks before a horizontal adjustment is
recognized.</p>

<p style="margin-left:11%;">-playerresizedelay 0..32</p>

<p style="margin-left:22%;">this controls, similar to the
above, the internal GTIA propagation delay until a change of
a player/missile size register becomes effective, and thus
the distance in screen hires pixels from the modification to
the position where the change becomes visible. The default
is six half color-clocks.</p>

<p style="margin-left:11%;">-playerreshapedelay 0..32</p>

<p style="margin-left:22%;">quite similar again, this
setting controls the propagation delay for player shape
changes, i.e. how long it takes for a write to the P/M
graphics register to propagate to the output logic of GTIA.
If the write comes too late, the shape change will become
visible only on the next scanline - unless GTIA fetches the
data through the ANTIC DMA, of course.</p>

<p style="margin-left:11%;">-colormapname filename</p>

<p style="margin-left:22%;">requires a filename to a color
map to be used instead of the default PAL or NTSC color map.
The color map file must be exactly 768 bytes long and
contains for each Atari color a red, green and blue color
triple, eight bits per channel.</p>

<p style="margin-left:11%;">-playertrigger.0
all|players|missiles|none</p>

<p style="margin-left:22%;">The first out of four otherwise
identical options sets the ability of player zero to
generate collisions with other objects on the screen. Note
that this <b>does not</b> change the ability of player zero
to <b>detect</b> collisions itself, though. It just removes
the ability of other players or missiles to collide with
it.</p>

<p style="margin-left:22%; margin-top: 1em">If this option
is set to <b>all,</b> then player zero can create collisions
with all other objects, for the <b>players</b> setting, only
collisions with other players are generated and missiles
never see any collisions with player zero. For the
<b>missiles</b> setting, the situation is reversed and only
missiles can detect collisions to player zero. Finally, for
the <b>none</b> argument, player zero generates no
collisions at all.</p>

<p style="margin-left:11%;">-playertrigger.1
all|players|missiles|none</p>

<p style="margin-left:22%;">works similar to the above
except that it changes the ability of player one to generate
collisions.</p>

<p style="margin-left:11%;">-playertrigger.2
all|players|missiles|none</p>

<p style="margin-left:22%;">changes the abilities of player
two and, finally,</p>

<p style="margin-left:11%;">-playertrigger.3
all|players|missiles|none</p>

<p style="margin-left:22%;">modifies the collision
abilities of player three.</p>

<p style="margin-left:22%; margin-top: 1em">Note that there
are no options to modify the collision abilities of a
missile since it has none in the real hardware. A missile
can never create a collision with a player itself, or any
other object. Rather, the situation is somewhat reversed
from the expected logic: A player creates a collision to a
missile, and hence, its ability to collide with missiles
must be turned off to avoid detection of player-missile
collisions.</p>

<p style="margin-left:11%;">-playfieldtrigger.0
all|players|missiles|none</p>

<p style="margin-left:22%;">Modifies the abilities of
playfield zero, i.e. the first foreground color, to generate
collisions to other objects. Similar to the above set of
four options, playfields can be allowed to generate
collisions to all objects, players only, missiles only or no
objects at all.</p>

<p style="margin-left:11%;">-playfieldtrigger.1</p>

<p style="margin-left:22%;">Triggers the ability of
playfield one to generate collisions; otherwise, similar to
the above.</p>

<p style="margin-left:11%;">-playfieldtrigger.2</p>

<p style="margin-left:22%;">The same again for playfield
two.</p>

<p style="margin-left:11%;">-playfieldtrigger.3</p>

<p style="margin-left:22%;">the same once again for
playfield three.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ANTIC
Options</b> <br>
The following options control the DMA controller and the
playfield graphics generator chip: <br>
-videomode PAL|NTSC</p>

<p style="margin-left:22%;">This option is intentionally
identical to the GTIA option of the same name and controls
the video system ANTIC should emulate. As for ANTIC, this
switch controls the height of the video output. For
<b>PAL</b> , a total of 312 lines is generated, and for
<b>NTSC</b> , only 262 lines of output are displayed. Note
that not all lines are available for graphics as the
vertical retrace takes up some of them.</p>

<p style="margin-left:11%; margin-top: 1em"><b>POKEY
Options</b> <br>
The next set of options influences the sound generation. For
sound output, the <i>Open Sound System</i> driver for your
sound card, more specifically, <b>/dev/dsp</b> must be
available. Alternatively, sound output can be written into a
<i>.wav</i> file and replayed later by a suitable tool, e.g.
XMMS. Alternative sound outputs are <i>SDL</i> or
<i>Alsa</i> , depending on their availibility. See the
<b>Machine Settings</b> section for more details.</p>

<p style="margin-left:11%; margin-top: 1em">The following
set of switches will not change the output of the sound, but
rather the emulation of the POKEY chip generating the audio
signal that is further processed by the OSS module described
below.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b> If
the &ldquo;stereopokey&rdquo; emulation is enabled, a second
set of Pokey control options appears under the topic
&ldquo;extrapokey&rdquo;. This set is identical to the set
described here. <br>
-volume 0..300</p>

<p style="margin-left:22%;">Controls the overall volume of
the POKEY output in percent compared to normal output. 300%
is loudest and 0 disables the output. The default is
100%.</p>

<p style="margin-left:11%;">-gamma 50..150</p>

<p style="margin-left:22%;">Controls the output linearity
of the POKEY D/A converter in percent. 100% is a perfectly
linear output (provided the sound card output is linear).
Values smaller than 100% cause sublinear behaivour (high
amplitudes appear smaller than they should), values higher
than 100% cause superlinear characteristics (high amplitudes
are louder than they should). Real pokey chips typically
show sublinear characteristics with a gamma value around 70%
to 80%.</p>

<p style="margin-left:11%;">-videomode PAL|NTSC</p>

<p style="margin-left:22%;">Even though Pokey is not a
video interface circuit, its timing is controlled by the
system base frequency which is related to the video mode.
This option controls whether Pokey should find itself in a
PAL or NTSC system; it changes the audio base frequencies
slightly.</p>

<p style="margin-left:11%;">-siosound bool</p>

<p style="margin-left:22%;">Enables or disables the serial
transfer sound, provided the <b>siopatch</b> is not enabled
and bypasses hardware driven serial i/o. This option enables
a more complete Pokey emulation by also taking care of the
serial transfer modes for generating sound. Thus, you get
the very unique &ldquo;Atari sound effects&rdquo; for all
kinds of disk or tape access.</p>

<p style="margin-left:11%;">-cycleprecise bool</p>

<p style="margin-left:22%;">Controls wether the Pokey
emulation works cycle-precise, that is, whether pokey
interrupts and potentiometer registers are are updated and
queried on a cycle by cycle basis. This allows a more
precise emulation, though it also requires more computing
power.</p>

<p style="margin-left:11%;">-filterconstant 0..1024</p>

<p style="margin-left:22%;">controls the time constant for
an optional high-pass filter that is applied to the audio
output signal generated by the Pokey emulation. This
high-pass filter cancels any DC offset in the sound
generation that might cause trouble for audio cards or
amplifiers, especially when the audio output level is close
to the maximum. The lower the filter constant, the more
frequencies are cut-off by the filter. Setting the filter
constant to zero disables the filter. The default setting is
512.</p>

<p style="margin-left:11%;">-recordasSAP bool</p>

<p style="margin-left:22%;">If this option is enabled, the
Pokey output is recorded on every vertical blank in a
<b>SAP</b> type R file. In principle, such files could be
played back as music files by third party software.
Unfortunately, type R does not seem to be well supported at
this time.</p>

<p style="margin-left:11%;">-sapname name</p>

<p style="margin-left:22%;">This option defines the name of
the song that is currently recorded, and also the file name
the song will be saved under. The file will be created in
the directory the emulator was started in, and the file name
will be generated by appending &ldquo;.sap&rdquo; to the
song name.</p>

<p style="margin-left:11%;">-sapauthor name</p>

<p style="margin-left:22%;">Defines the name of the author
to be recorded in the <b>SAP</b> output file. This option
may remain unset in which case an unknown author will be
indicated.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PIA
Options</b> <br>
The following set of options modify the emulation of the
<i>Peripheral Interface Adapter</i> chip. <br>
-mathpackcontrol bool</p>

<p style="margin-left:22%;">enables control of the
<b>MATHPACKDISABLE</b> signal thru bit 6 of PIA port B. This
function is only required for some dedicated hardware of the
author of this program and should be otherwise left
alone.</p>

<p style="margin-left:11%; margin-top: 1em"><b>MMU
Options</b> <br>
The following options control the features of the <i>Memory
Management Unit.</i> For the 800 and 400, no real MMU chip
has been used. Rather, the MMU is a set of standard logic
gates that control the memory map of the system. From the
800XL and up, all these gates have been integrated into a
dedicated hardware chip called the MMU. Regardless of these
technicalities, the memory management logic is controlled by
the following options: <br>
-4kextended bool</p>

<p style="margin-left:22%;">Enables additional 4K of memory
in the range of 0xc000..0xd000 for the Atari 400 and 800
models. For the XL and XE, this memory region contains parts
of the ROM and is never available. For the 400 and 800, this
region is otherwise blank.</p>

<p style="margin-left:11%;">-axlonram bool</p>

<p style="margin-left:22%;">Enables emulation of Axlon type
RAM expansions that are controlled by address 0xcfff. These
RAM disks have pages of 16K each that are mapped into the
memory from 0x4000 to 0x8000.</p>

<p style="margin-left:11%;">-axlonbankbits 0..8</p>

<p style="margin-left:22%;">Defines the number of bits
within the page control port 0xcfff of the Axlon RAM disk
emulation used for the page selection. The more bits are
enabled, the more banks are available. Each additional bit
doubles the number of 16K banks.</p>

<p style="margin-left:11%;">-xebankbits 0..8</p>

<p style="margin-left:22%;">This option is only available
if the emulator is setup to the 130XE machine type. Then, it
defines the number of PIA port B RAM bits used to define the
selected/active bank. The 130XE uses two bits for selecting
the bank, and hence has four pages of 16K, making a total of
64K extended RAM. Note that the more bank bits you enable
here, the less compatible the resulting emulation will be to
a &ldquo;straight&rdquo; 130XE. Specifically, you loose the
proprietry PIA Port B &ldquo;MathPackDisable&rdquo; at three
bits, the selftest at four bits, the Basic ROM at five bits,
separate Antic access at six bits, OS Rom mapping at seven
bits and CPU access control at eight bits.</p>

<p style="margin-left:11%; margin-top: 1em"><b>OsROM
Options</b> <br>
The following options control the emulation of the
<i>Operating System ROM</i> and related features, most
notably various Os patches that are installed into it.
<b>NOTE:</b> Original Atari ROM images are not included in
the distribution of Atari++ due to copyright restrictions,
but Atari++ provides an Os emulation that works as well in
most cases. Note that the Basic ROM and the Os ROM are
contained in two separate chips and hence also emulated
separately. <br>
-osapath filename</p>

<p style="margin-left:22%;">Gives the location of the OS A
ROM image. This file contains a simple dump of the memory
area 0xd800..0xffff of the original first revision Os of the
Atari 800 and 400, or a dump from 0xf800..0xffff for the
5200 console.</p>

<p style="margin-left:11%;">-osbpath filename</p>

<p style="margin-left:22%;">Specifies the location of the
second revision for the Atari800 and 400 ROM image file.</p>

<p style="margin-left:11%;">-os1200path filename</p>

<p style="margin-left:22%;">Specifies the location of the
Atari 1200XL ROM image. This is an early version of the
Atari 800XL image with some ROM bugs the emulator has to
keep care of.</p>

<p style="margin-left:11%;">-osxlpath filename</p>

<p style="margin-left:22%;">Specifies the location of the
Atari 800XL and later model ROM image. This ROM image
contains the memory areas 0xc000..0xd000, the self-test that
can be mirrored to 0x5000..0x5800, and the math-pack and the
upper ROM area from 0xd800 to 0xffff, in that order. This is
also the natural order within the real ROM chip, which is
twice as large as for the former Atari models.</p>

<p style="margin-left:11%;">-os5200path filename</p>

<p style="margin-left:22%;">specifies the location of the
5200 ROM image.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b> If
no ROM image is available, the built-in ROM will be used.
This ROM is an XL/XE type of operating system <b>only</b>
and thus requires a the 800XL or 130XE machine type for
proper emulation.</p>

<p style="margin-left:11%; margin-top: 1em">If none of the
above options have been given on the command line, then
Atari++ will try to locate them itself, or fall back to the
built-in ROM if it is unable to find any ROM. It therefore
looks into the directory &ldquo;roms&rdquo; in the current
directory. For the XL operating system, it tries to find a
file named &ldquo;atarixl.rom&rdquo; in this directory. For
the Os A resp. Os B image, files named
&ldquo;atariosa.rom&rdquo; resp. &ldquo;atariosb.rom&rdquo;
are searched, and loaded if found. <br>
-ostype Auto|OsA|OsB|Os1200|OsXL|5200|BuiltIn</p>

<p style="margin-left:22%;">Defines which kind of ROM shall
be loaded into the system. Note that this need not to be
identical to the type of machine you are emulating, even
though this is the default and probably the most useful
selection. The 5200 console is an exception: Its ROM will
not be accepted by anything but the 5200 machine, and any
other machine type will not accept the 5200 ROM. This is
because the mapping of the hardware differs between the
&ldquo;regular&rdquo; Atari 8 bit systems and the 5200
console, making the ROMs non-portable.</p>

<p style="margin-left:22%; margin-top: 1em">The
&ldquo;builtin&rdquo; option selects the built-in ROM
emulation that implements a fully-features 800XL/130XE ROM.
This ROM emulation is used if no other ROM image is found.
More on this ROM image in the &ldquo;Os Emulation&rdquo;
section below.</p>

<p style="margin-left:22%; margin-top: 1em">The
&ldquo;Auto&rdquo; option, which is the default, does not
select a specific ROM, but rather picks a suitable rom image
for the selected machine.</p>

<p style="margin-left:11%;">-installpdevice bool</p>

<p style="margin-left:22%;">Selects whether a patched
<b>P:</b> device handler should be installed that redirects
printer output directly to the printer component. If this
patch is not installed, printer emulation will be re-routed
thru the <i>SIO</i> emulation described below. This will
work as much as this direct patch, but might be somewhat
slower.</p>

<p style="margin-left:11%;">-installrdevice bool</p>

<p style="margin-left:22%;">Installs optionally an RS232
interface box handler for serial transfer. On a real Atari,
this handler would be loaded from the interface box by a
tiny bootstrap code that is usually part of an
&ldquo;AUTORUN.SYS&rdquo; or &ldquo;HANDLERS.SYS&rdquo;
file; even though this bootstrapping is also emulated, the
resident handler patched in by this option has the advantage
that it doesn&rsquo;t take up any RAM space, unlike the
handler provided by the interface box emulation itself.
However, in case a program tries to trick around with the
interface box, the bootstrapped 6502 based handler provides
closer emulation than the native emulation implemented by
this option. Otherwise, the native emulation and the 6502
implementation provided by the emulated 850 interface box
are functionally identical.</p>

<p style="margin-left:22%; margin-top: 1em">Note further
that this option only installs the CIO emulation layer of
the 850 interface box. <b>You still need to enable the
interface box itself</b> with the &ldquo;-Enable850
on&rdquo; option.</p>

<p style="margin-left:11%;">-installhdevice bool</p>

<p style="margin-left:22%;">If enabled, the <b>C:</b>
cassette handler is replaced by an emulator specific
<b>H:</b> (Host) handler that mirrors parts of the host
filing system into the emulator. In specific, booting from
tape, or tape access in Basic with the <b>CLOAD</b> and
<b>CSAVE</b> statements is then not available. The <b>H:</b>
device understands all major CIO commands and most XIO
commands, following the conventions of DOS 2.0S, e.g.
<b>RENAME</b> and <b>LOCK</b> XIOs are available by its DOS
2.0S command IDs. More about the <b>H:</b> device can be
found below in a specific section.</p>

<p style="margin-left:11%;">-installedevice bool</p>

<p style="margin-left:22%;">This option installs a specific
patch which replaces the operating system editor device,
<b>E:</b> and to some degree, the keyboard device, <b>K:</b>
by emulator specific routines that redirect input and output
from and to the operating system handler to the standard
input and output streams. That is, instead of typing into
the emulator window, keyboard data is read from the standard
input, and output to the editor device is echoed on the
console. In addition, the editor device stream also goes to
the front-end of the emulator. Note that this mode relies on
the line-buffering of the console and does not provide a
full-screen editor, unlike the Atari. You cannot move the
cursor back to a previous line and re-enter it. Furthermore,
input will not be seen by the emulatur until you press
<b>RETURN</b> at the end of the line, and only a very
limited set of control characters, namely those standardized
in ANSI-C, will be transposed from ASCII to ATASCII. For
example, cursor movement sequences, which are
console-specific, are not available with this patch. The
major purpose of this patch is to script the emulator, less
to redirect I/O to a terminal. For that, consider the
<i>curses</i> front-end instead.</p>

<p style="margin-left:11%;">-installhasdisk bool</p>

<p style="margin-left:22%;">Changes the device letter under
which the host handler will be installed. By default, the
handler will be called <b>H:,</b> but if this flag is set,
then the handler will be inserted as <b>D:</b> giving you
emulated disk access. Programs that entirely access the disk
thru this handler, for example BASIC programs, will then run
off the host filing system.</p>

<p style="margin-left:11%;">-h1dir filename</p>

<p style="margin-left:22%;">Defines the directory where the
first unit of the <b>H:</b> device should be anchored. Files
in this directory are accessible thru <b>H1:</b> or
<b>H:,</b> provided the host handler is patched in by the
option above.</p>

<p style="margin-left:11%;">-h2dir filename</p>

<p style="margin-left:22%;">Specifies the anchor path for
the second unit of the <b>H:</b> handler, accessible by
<b>H2:.</b></p>

<p style="margin-left:11%;">-h3dir filename</p>

<p style="margin-left:22%;">The host directory for the
third unit of the <b>H:</b> handler.</p>

<p style="margin-left:11%;">-h4dir filename</p>

<p style="margin-left:22%;">Finally, the directory for the
fourth unit of the host handler.</p>

<p style="margin-left:11%;">-siopatch bool</p>

<p style="margin-left:22%;">If enabled, then serial
input/output handling is routed thru an Os patch to the
emulated devices directly instead of using the detour thru
the POKEY emulation and the emulation of the serial port.
This speeds up serial access, especially disk drive access,
noticeably, but might cause compatibility problems with some
critical software that expects precise timing and exact
behavior of the serial hardware.</p>

<p style="margin-left:11%;">-installmathpatch bool</p>

<p style="margin-left:22%;">Installs optionally a series of
patches into the MathPack module of the operating system;
this part of the Os is responsible for floating point
support and is used heavely by AtariBasic and other
programming languages. This patch replaces the ROM based
math routines by custom patches that make use of the host
system FPU instead, hence speeding up any kind of floating
point operation dramatically. Due to the limited precision
of both the Atari floating point model and the host system
floating point system, computations performed by the orginal
MathPack might differ slightly from the results obtained
from the patch, though the difference is typically
neglectible and below the precision of the MathPack
itself.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KEYBOARD
Options</b> <br>
The following set of three options relates to the way how
Atari++ uses the host system keyboard to emulate the Atari
keyboard. They currently only influence the emulation of the
console keys which are strictly speaking not part of the
keyboard hardware of the Atari. <br>
-holdoption bool</p>

<p style="margin-left:22%;">Defines whether the emulator
shall emulate pressing the <b>Option</b> key during the
coldstart. The Atari XL/XE roms query the state of this key
during bootstrap and disable the built-in BASIC rom in case
the <b>Option</b> key is held down. Hence, this option
should be set to be able to play (non-BASIC) games on an
emulated XL/XE system.</p>

<p style="margin-left:11%;">-holdselect bool</p>

<p style="margin-left:22%;">Defines whether the
<b>Select</b> console key shall be pressed during the cold
start process. No known Os currently evaluates the state of
this key on bootstrap, though.</p>

<p style="margin-left:11%;">-holdstart bool</p>

<p style="margin-left:22%;">Similar to the above, enables
or disables the activation of the <b>Start</b> console key
on coldstart. This signals a boot process from the tape
recorder.</p>

<p style="margin-left:11%;">-bufferkeys bool</p>

<p style="margin-left:22%;">Atari++ comes with a smart
keyboard type-ahead buffer that allows you to type faster
than the original Atari hardware is able to react.
Unrecognized keys are buffered until the emulator is able to
fetch them. While this feature helps a lot when programming
on the emulator, fast gameplay using the keyboard as input
device might become more problematic if keys are delayed
rather than swallowed.</p>

<p style="margin-left:11%;">-keybutton.0.enable bool</p>

<p style="margin-left:22%;">This option is only available
for the Atari 5200 emulation; it allows the generation of
5200 &ldquo;keyboard&rdquo; events thru joystick buttons. If
this specific option is enabled, the &rsquo;0&rsquo; key on
the Atari 5200 keypad can be connected to a joystick button,
similar options exist for all other numeric keys as well as
for the haskmark and the asterisk, named
&ldquo;keybutton.hashmark.enable&rdquo; and
&ldquo;keybutton.asterisk.enable&rdquo;, respectively.</p>

<p style="margin-left:11%;">-keybutton.0.button 1..4</p>

<p style="margin-left:22%;">If the above option is enabled,
this option controls which of the virtual buttons of a
joystick type device is used to trigger the keyboard event
for the &rsquo;0&rsquo; key on the 5200 keypad. The button
numbers required here do not directly relate to the hardware
numbering of the Os specific joystick device, but they
rather refer to the button event numbers used by the analog
joystick interfaces of Atari++. The
&ldquo;First_Button&rdquo; option of this device then
defines which hardware button is responsible for generating
the virtual button 1 events, and so on.</p>

<p style="margin-left:22%; margin-top: 1em">Similar options
exist for the keypad buttons 0 to 9, and for the asterisk
and the hashmark, namely as
&ldquo;keybutton.hashmark.button&rdquo; and
&ldquo;keybutton.asterisk.button&rdquo;.</p>

<p style="margin-left:11%;">-keybutton.0.sensitivity
0..32767</p>

<p style="margin-left:22%;">controls the sensitivity of the
reaction, i.e. the minimum amplitude of the button input
required to trigger the keyboard event. Since buttons are
usually digitial, this option can be be left alone in most
cases. Similar options exist for the remaining keypad
buttons.</p>

<p style="margin-left:11%;">-keybutton.0.port
devicename</p>

<p style="margin-left:22%;">defines the input device for
the Atari 5200 keypad &rsquo;0&rsquo; button. This device is
setup in the very same way as for the <i>JOYSTICK</i>
emulation and we refer to this chapter instead. Similar
options exist for all other keypad keys.</p>

<p style="margin-left:11%; margin-top: 1em"><b>CARTRIDGE
Options</b> <br>
The next set of options allows to insert a cartridge into
the emulated cartridge slot of the system. Currently, only
the left cart slot of the Atari 400 and 800 , resp. the one
and only cart slot of all later models is emulated. <br>
-cartpath filename</p>

<p style="margin-left:22%;">specifies the filename of the
cartridge image to load.</p>

<p style="margin-left:11%;">-carttype <br>

none|8k|16k|32k|oss|ossb|sdx|xegs|bountybob|flash|megarom|atrax</p>

<p style="margin-left:22%;">specifies the type of cartridge
to load. Unfortunately, the emulator cannot figure out the
cart type itself in all cases just by looking at the image
file. Therefore, this option has to be given along with the
option above.</p>

<p style="margin-left:22%; margin-top: 1em"><b>None</b> is
a dummy option that just disables the cart, and hence
ignores the above option altogether.</p>

<p style="margin-left:22%; margin-top: 1em"><b>8K</b>
emulates an 8K sized plain cartridge that is mapped into the
memory from 0xa000 to 0xbfff.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Right8K</b>
this cartridge type is only available for the Atari800
hardware type and emulates a cartridge for the right cart
slot of this system that gets mapped to the area 0x8000 to
0x9fff.</p>

<p style="margin-left:22%; margin-top: 1em"><b>16K</b>
emulates a plain 16K cart occupying the memory region from
0x8000 to 0xbfff.</p>

<p style="margin-left:22%; margin-top: 1em"><b>32K</b>
emulates 32K cartridges of the 5200 game system. This option
and the 32K rom images will not be accepted for all other
machine types and hence remains unavailable then.</p>

<p style="margin-left:22%; margin-top: 1em"><b>32KEE16</b>
emulates a 5200 game system cartridge with a 16K sized image
file with incomplete addressing that occupies 32K ROM
space.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Debug32</b>
emulates a 32K debug cartridge for the 5200 game system with
two 16K banks mapped into the area from 0x8000 to
0xbfff.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Oss</b>
emulates an Oss super cartridge that is mirrored into the
memory map from 0xa000 to 0xbfff, but is 16K sized
internally. The cartridge therefore provides a
bank-switching mechanism thru the <b>CARTCTRL</b> system
component, as it consists internally of two ROM chips,
called <b>RomA</b> and <b>RomB</b> in the following. The
lower region 0xa000 to 0xafff is variable and can be
bank-switched, the upper region 0xb000 to 0xbfff is
hard-wired to the upper part of <b>RomA.</b> The following
table shows the mapping for the lower region:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-141941.png" alt="Image grohtml-141941.png"></p>

<p style="margin-left:22%; margin-top: 1em"><b>OssB</b> is
also an Oss super-cart except that the cartridge ROM has
been dumped to disk in a different order and hence the
addressing of the cartridge ROM contents is different. If
the <b>Oss</b> option does not work, try this option
instead.</p>

<p style="margin-left:22%; margin-top: 1em"><b>SDX</b>
emulates a 64K large ROM image with eight banks mapped into
the region of 0xa000 to 0xbfff.</p>

<p style="margin-left:22%; margin-top: 1em"><b>EXP</b> a
variant of the SDX cartridge with a slightly different bank
switching logic.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Diamond</b>
another variant of the SDX cartridge type with just another
bank switching logic.</p>

<p style="margin-left:22%; margin-top: 1em"><b>XEGS</b>
emulates a variable size XEGS cartridge. This cart type
occupies 16K of memory within the address space of the 6502
CPU but consists of several banks that can be mapped into
the 0x8000...0x9fff region.</p>

<p style="margin-left:22%; margin-top: 1em"><b>ExtXEGS</b>
a mildy extended version of the XEGS cartridge type that
additionally allows disabling the cartridge.</p>


<p style="margin-left:22%; margin-top: 1em"><b>BountyBob</b>
emulates the 40K sized BountyBob cartridge for the 5200
games system. This cartridge uses a very unique bank
switching mechanism that requires its own emulation provided
by this option.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Flash</b>
Emulates Steven J. Trucker&rsquo;s &ldquo;AtariMax&rdquo;
flash ROM cart. This is a 128K or 1MB cart with
bank-switching logic that is mapped into the 0xa000...0xbfff
region. This cart type allows flashing, and thus the cart
ROM can be modified by the emulation process. The emulator
will ask you to save back the cart image as soon as the cart
shall be removed again.</p>

<p style="margin-left:22%; margin-top: 1em"><b>MegaROM</b>
Emulates the various types of the Mega ROM cartridges. These
carts come in varous sizes and map in as 16K banks in the
area of 0x8000...0xbfff.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Atrax</b>
Emulates the 128K bank switching Atrax cartridges that map
in as 8K banks in the area of 0xa000...0xbfff.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Will</b>
Another super cartridge type of 32K or 64K size that maps
its 8K sized banks into the area of 0xa000 to 0xbfff.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Phoenix</b>
This type emulates the Phoenix and Blizzard super
cartridges. The first is a regular 8K cart that can be
disabled, the latter is a 16K switching cart. Both are
emulated by the same cart type.</p>

<p style="margin-left:22%; margin-top: 1em"><b>ATMax</b> A
super cart that comes as 128K or 1MB cartridge.</p>

<p style="margin-left:11%;">-rtime8 bool</p>

<p style="margin-left:22%;">enables or disables the
emulation of the RTime-8 pass-thru cartridge. This this a
cartridge rom that contains a battery buffered real-time
clock and passes the cartridge slot connections thru to be
able to use the real-time clock together with other
cartridges. The default is not to enable the real-time clock
cartridge.</p>

<p style="margin-left:11%; margin-top: 1em"><b>CARTFLASH
Options</b> <br>
The flash cartridge type is the only cart type that can be
configured by the command line and the GUI. Currently, there
is only a single option available, namely: <br>
-enablecartflash</p>

<p style="margin-left:22%;">If this option is disabled, the
flash cartridge mapping will be disabled on the next reset.
However, the cart still receives the bank mapping signals
and thus can be re-enabled by software. This is useful if
you want to re-flash the cartridges by Steve Trucker&rsquo;s
flashing software: Just disable this switch, insert the
flash software disk, and reboot. The cart will be disabled,
the Atari will boot from the inserted disk, and the flash
software will re-enable the cartridge, allowing you to
overwrite its contents. To write the cart image back to
disk, change the cartridge type to &ldquo;none&rdquo; or
insert any other cart.</p>

<p style="margin-left:11%; margin-top: 1em"><b>BASIC
Options</b> <br>
The following options control the function of the <b>BASIC
Rom</b> of the Atari 800XL and later models. Since the Atari
800 and 400 models do not come with a built-in BASIC, these
options are ignored for the earlier models; you&rsquo;d need
to insert the BASIC as a regular 8K cartridge for them.
Furthermore, whether the basic is mapped for the XL and
later series depends on whether the <b>Option</b> console
key is held down during bootstrap. This option is part of
the keyboard options below, even though it influences the
working of the basic ROM for the XL and XE series.</p>

<p style="margin-left:11%; margin-top: 1em">Atari published
three versions of their basic, Revisions A, B and C. Each
has its own bugs, with revision B having the most critical
bugs (really) and revision C is the most bug-free. In
addition, the emulator also includes a built-in Basic
emulation, <b>Basic++</b> , which fixes most bugs of all
three revisions. <br>
-basicapath filename</p>

<p style="margin-left:22%;">This option specifies the file
name of the Revision A Basic rom image if you have one. The
ROM image is a simple 8K memory dump of the ROM appearing
between 0xa000 and 0xbfff. Revision A was only available as
cartridge on the 800 and 400 models; if you want to emulate
these two models, insert Revision A as cartridge, see the
<b>CARTRIDGE</b> section of this manual for details.
Revision A contains several bugs and is only of historical
interest.</p>

<p style="margin-left:11%;">-basicbpath filename</p>

<p style="margin-left:22%;">This option specifies the file
name of a Revision B Basic rom image. This revision was
shipped with most early 800XL and 600XL machines. It
contains one critical bug that crashes the Basic interpreter
potentially when entering source code. It should best be
avoided.</p>

<p style="margin-left:11%;">-basiccpath filename</p>

<p style="margin-left:22%;">This option selects the
location of a Revision C Basic rom image. This revision was
delivered with many later 800XL and 600XL models and the
last and final XE series. It is the most bug free of the
three Basic revisions Atari produced and the recommended
selection if you want an original Basic.</p>

<p style="margin-left:11%;">-basictype
auto|reva|revb|revc|builtin|disabled</p>

<p style="margin-left:22%;">Selects the Basic version
Atari++ should emulate. The default is &ldquo;auto&rdquo;,
which selects Revision C on XL and XE machines if is
available, otherwise the built-in <b>Basic++.</b></p>


<p style="margin-left:22%; margin-top: 1em">&ldquo;reva&rdquo;
selects the revision A Basic, &ldquo;revb&rdquo; the
revision B basic and &ldquo;revc&rdquo; the revision C
basic. &ldquo;builtin&rdquo; uses Basic++, which is compiled
into the emulator and always available.
&ldquo;disabled&rdquo; removes the Basic completely, making
it unavailable indepedently of the state of the
<b>Option</b> key on all machine types.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SIO
Options</b> <br>
The <i>Serial Input/Output</i> module is a specific part of
the operating system taking care of serial communication.
The Atari++ emulation component of the same name controls
the low-level emulation features of all devices emulated on
the serial port, hence the disk-drives, the printer, the 850
serial interface box and the tape. The emulation of the
serial port can be bypassed by the -siopatch option
described in the <b>OS Option</b> section above, giving a
noticeable speedup for disk-drive and printer, but possibly
also causing compatibility problems for software that
depends on precise timing or side-effects of the Os
implementation. You usually need not to care about the
settings below as they closely match those of typical serial
hardware anyhow. <br>
-serincmddelay 0..240</p>

<p style="margin-left:22%;">The amount of time taken by a
serial device to accept a command frame. This time is given
in horizontal blanks. It defaults to 50 lines.</p>

<p style="margin-left:11%;">-readdonedelay 0..240</p>

<p style="margin-left:22%;">The time taken for a serial
read command to complete. For the disk-drive emulation, this
would emulate the time required to read a sector from disk
up to the time where the first byte of the sector arrives at
the port. This setting also defaults to 50 lines.</p>

<p style="margin-left:11%;">-writedonedelay 0..240</p>

<p style="margin-left:22%;">Required time to complete a
write command. For the disk-drive, this is the time taken
from the last byte of a sector arriving at the drive up to
the time where the disk-drive sends the acknowledgement
frame. This setting defaults again to 50 lines.</p>

<p style="margin-left:11%;">-formatdonedelay 0..1024</p>

<p style="margin-left:22%;">Required time to format a disk
in a disk-drive, measured as the time from issuing the
command up to the time where the first byte of the sector
status map arrives at the serial input. This is again given
in horizontal lines. Since the Os assumes that the timing of
formatting is a bit more relaxed than the regular reading
time - yes, formatting is a read command for the Atari -
this is a separate option, defaulting to 400 horizontal
lines.</p>

<p style="margin-left:11%; margin-top: 1em"><b>PRINTER
Options</b> <br>
This option set controls the printer emulation. Commands and
data enter this emulation either by the SIO, or directly by
the <b>P:</b> handler should it be patched into the Os. See
the <b>OS Options</b> for more details on this. This option
set is used in either case, no matter how the emulated
printer is accessed. <br>
-printtarget tospoolcommand|tofile</p>

<p style="margin-left:22%;">selects where printer output is
sent to. For the <b>tospoolcommand</b> selection, printer
output is piped into the <b>printcommand</b> selected by the
option below. This is typically the &ldquo;lpr&rdquo; or
&ldquo;lp&rdquo; command on Unixoid systems. For
<b>tofile</b> , printer output is sent to a regular file. On
some systems, this might be the only available option to
print at all.</p>

<p style="margin-left:11%;">-printcommand file</p>

<p style="margin-left:22%;">Specifies the command used to
print out text on the host system. The text arriving at the
emulated printer will wait in a queue and will be flushed
regularly, appearing at the <b>STDIN</b> of this command.
Typically, this should be either <b>lpr</b> or <b>lp</b> ,
depending on the printing system you use at your
machine.</p>

<p style="margin-left:11%;">-printfile filename</p>

<p style="margin-left:22%;">Specifies the file printer
output is sent to should this type of output be selected.
This is by default empty, disabling printer output
completely, though the printer appears to be turned on.</p>

<p style="margin-left:11%;">-appendtoprintfile bool</p>

<p style="margin-left:22%;">defines whether the printer
output file specified by the previous option is overwritten
on each printer-output or the new output is just appended at
the end of it. By default, new printer output overwrites
older printer dumps.</p>

<p style="margin-left:11%;">-enableprinter bool</p>

<p style="margin-left:22%;">Enables or disables the
emulated printer. If set to <b>off,</b> the printer will not
react on any SIO commands as if it has been turned off.
Otherwise, printing will be allowed.</p>

<p style="margin-left:11%;">-transposeeol bool</p>

<p style="margin-left:22%;">The Atari doesn&rsquo;t use the
regular <b>LF</b> character to separate lines on the printer
output. Rather, it uses the character 0x9B (CSI in the ANSI
set, named EOL on Ataris) to separate lines. Hence, for
printing text, EOL has to be transposed into line feeds by
this option, which is also the default. However, for
graphics output, this character transposition will change
the meaning of the graphics data send to the printer, and
will hence distort the graphics. <b>NOTE:</b> Currently,
Atari++ does not include the emulation of a graphics
printer. All control and graphics sequences sent out to the
emulated printer will be spooled directly into the print
command without interpreting them further.</p>

<p style="margin-left:11%;">-flushdelay 0..60</p>

<p style="margin-left:22%;">This specifies the delay in
seconds from the last data arriving at the emulated printer
until the collected text/graphics are printed out. Hence, if
data is printed at a rate lower given by this delay, they
will appear in separate spool jobs. This delay defaults to
five seconds.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SPEED
Options</b> <br>
The following set of options controls the timing of the
emulator. Several other factors influence the maximum speed,
though. First of all, the graphical front-end of the
emulator might be more or less performing. For full-screen
emulation, the <i>SDL</i> front-end is performing well
provided no pixel upscaling is used. In all other cases, the
<i>X11</i> frontend offers higher speed. This is not the
fault of the emulator, but rather a matter of the poor
performance of SDL. Furthermore, the sound emulation has
some impact as well. For software speech emulation, high
sampling rates and slim buffers are a must, causing
additional software overhead and higher CPU loads. To
maximizing the speed, either run the <i>X11</i> frontend on
1x1 or 1x2 pixel sizes and reduce the quality of the audio
output. <br>
-unlockrate bool</p>

<p style="margin-left:22%;">If this option is set to true,
then a custom, non-standard frame rate can be selected that
is not locked to the video mode (see below) of the emulated
machine. The default is to disable this option and thus to
lock the frame rate to the natural frame rate of the
emulated machine.</p>

<p style="margin-left:11%;">-framerate 1..100</p>

<p style="margin-left:22%;">This option specifies the
screen refresh rate, to be given in milliseconds per frame.
A standard PAL screen with 50 frames per second requires 20
milliseconds per frame, a NTSC screen requires 17
milliseconds. This option defaults to 20, i.e. the PAL rate,
but is ignored unless the frame rate is unlocked with the
<b>unlockrate</b> switch above.</p>

<p style="margin-left:11%;">-maxmiss 1..16</p>

<p style="margin-left:22%;">Unlike the above, this option
controls how much frames the emulator may miss to keep the
emulation speed. If this is set to one, the emulator never
misses a frame, may become slow on less performing systems.
If set to a value higher than one, at most the specified
number of frames might be dropped to keep up the refresh
rate set by the option above. Hence, it does not hurt to
select a higher maxmiss rate on a fast machine, but it will
keep up the speed for more complex graphics on slower
machines as well at the cost of not emulating the video
output frequently.</p>

<p style="margin-left:11%;">-videodmode PAL|NTSC</p>

<p style="margin-left:22%;">Intentionally identical to the
same option of the ANTIC and GTIA emulation, this selects
the frame rate based on the video output mode. For a
<b>PAL</b> machine, this selects a freshmode of 50
frames/second, for a <b>NTSC</b> machine, the emulator will
try to generate 60 frames/second. This option is overridden
if the <b>unlockrate</b> switch above is enabled.</p>

<p style="margin-left:11%; margin-top: 1em"><b>DISKDRIVE
Options</b> <br>
The following set of options controls the emulation of up to
four disk drives. The diskdrive options consist of a base
name, a dot and the unit number specifying the unit of the
disk drive they control. Hence, all the following options
exist four times, and just differ by the digit behind the
dot. <br>
-enable.1 bool</p>

<p style="margin-left:22%;">Enables or disables the first
diskdrive. If set to <b>off,</b> the first drive will not
react as if it has been turned off, otherwise it will be
turned on. The default is to enable the first drive and to
disable all others.</p>

<p style="margin-left:11%;">-image.1 filename</p>

<p style="margin-left:22%;">Specifies the path to an image
file to be loaded into the drive. The Atari++ emulator
supports several kinds of image files: First, raw disk
images that keep the contents of the disk sector by sector.
These files are typically identifies by their extender
<i>.xfd.</i> The second available format is the so called
<i>.atr</i> format implemented by several other Atari
emulators. It consists of a tiny header describing the
format and the size of the disk plus the sector image. The
third format supported by Atari++ is that of Atari <i>binary
load files</i> or short, so called <i>.exe</i> files. These
files consist of a two 0xff byte header plus address
information where to place the data to load. These files are
booted by writing them as DOS 2.0S files onto disk,
toghether with a minimal game DOS header that bootstraps the
<i>.exe</i> format. Note that no full DOS will be available
for these files, though this emulation is sufficient for
most <i>.exe</i> based games right away. While the above
formats capture all high-level details of disks, they do not
include enough information to reproduce the low-level
behavior of the disk drive. Specifically, copy protected
disks cannot be represented by them. Atari++ supports for
that the <i>.atx</i> format, which includes pecularities
such as disk timing, duplicate sectors or sector defects.
Again, the emulator cannot create such disk images, but is
able to read from them. Atari++ also supports <i>.dcm</i>
images, which have been prepared by the &ldquo;Disk
Communicator&rdquo; program and are (slightly) compressed.
Similar to the <i>.exe</i> files, Atari++ cannot re-compress
these. Therefore, disk images of this type are marked
write-protected, making writes to these disks fail. All of
the above disk image types can be compressed by means of the
<b>gzip</b> program; Atari++ will then uncompress them on
demand as soon as the image gets loaded. Since it does not
re-compress images, these disks also always end up
write-protected. Last but not least, the emulator also
supports <i>.bas</i> files, which are tokenized Basic files.
To load such files, make sure that either a Basic cartridge
is inserted, or the Basic emulation is enabled. The Basic
program will <b>not</b> boot automatically if the emulated
machine is reset, unless <b>Basic++</b> , i.e. the built-in
Basic dialect, is selected and the Basic file is inserted
into the first drive. All other Basic dialects will see the
basic image as a file named &ldquo;AUTORUN.BAS&rdquo; on a
write-protected disk. To start the file, enter the
command</p>

<p style="margin-left:22%; margin-top: 1em">RUN
&quot;D:AUTORUN.BAS&quot;</p>

<p style="margin-left:22%; margin-top: 1em">manually on the
editor window of the emulated Basic and press
<b>RETURN.</b></p>

<p style="margin-left:11%;">-protect.1 bool</p>

<p style="margin-left:22%;">Enables or disables the
write-protection of the inserted disk. If set to <b>on,</b>
the disk image will be write-protected as if the
write-protection notch has been covered on a physical disk.
The emulator also write-protects disk images automatically
if the corresponding image is marked non-writeable by the
protection bits of the host operating system, or if the disk
is build up for the <i>.exe</i> binary load file emulation,
or comes in the already compressed <i>.dcm</i> Disk
Communicator format. Similarly, all <i>.gz</i> compressed
images and <i>.bas</i> files are write-protected, no matter
what the original file format has been.</p>

<p style="margin-left:11%;">-drivemodel.1 <br>

1050|810|815|happy1050|warpspeed810|speedy|xf551|usturbo|indusgt</p>

<p style="margin-left:22%;">selects the drive model to
emulate. The &ldquo;1050&rdquo; is the disk drive that
shipped with the XL series of computers, and the default
selection. It handles single or extended density disks of
720 or 1040 sectors, each of which is 128 bytes long. Note
that this drive type <b>does not</b> support ATR or XFD
images with sector counts or sector sizes that go beyond the
capabilities of this drive. The &ldquo;810&rdquo; is the
first disk drive that was available for the 800 and 400
models. It handles only single density disks, i.e. disks of
720 sectors of 128 bytes each. All other disk types will not
be accepted. The &ldquo;815&rdquo; drive is a dual-disk
drive supporting single or double density disks of 720
sectors, either 128 or 256 bytes per sector. The
&ldquo;xf551&rdquo; is the last floppy drive sold by Atari,
it allows single, extended, double and quadrupel density
disks. It has two heads and can read the disk from both
sides simultaneously. All other drive types are third party
extensions that allow higher transfer speeds and extended
sector formats. Note that the file management system that is
part of the built-in Os emulation does not make use of the
higher serial transfer speeds of these extensions, but
third-party file systems will be able to detect these drive
types and will then switch to a higher transfer speed.</p>

<p style="margin-left:11%; margin-top: 1em">Similar disk
drive options exist for drives two to four by replacing the
digit <b>1</b> in the above list by the appropriate drive
number.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SIOCABLE
Options</b> <br>
The following set of options control the overall setup of
Matthias Reichl&rsquo;s &ldquo;AtariSIO&rdquo; emulation. It
requires that the kernel interface and development files for
<i>/dev/atarsio</i> are available. Alternatively, the
<i>DirectSerial</i> can be used, which might be less
reliable since it cannot ensure correct timing. To make use
of the AtariSIO emulation, connect your Atari drive by means
of one of two possible interface cable types to the PC, and
disable the built-in disk drive emulation for the
corresponding drive unit. I.e. if your external drive has
been set to drive unit 1, the internal emulation for drive 1
has to be disabled by <b>-enable.1 false</b> , or
de-selecting the corresponding gadget in the DiskDrive menu.
<br>
-cabletype 1050-2-PC|ProSystem</p>

<p style="margin-left:22%;">selects the type of the cable
that has been used to interface a 1050 or 810 drive to the
PC. Currently, AtariSIO supports two cable types, the
&ldquo;1050-2-PC&rdquo; and the &ldquo;ProSystem&rdquo;
layout.</p>

<p style="margin-left:11%;">-enableatarisio bool</p>

<p style="margin-left:22%;">This is the overall
enabling/disabling option for the AtariSIO interface, no
matter which protocol is used.</p>

<p style="margin-left:11%;">-directserial bool</p>

<p style="margin-left:22%;">if enabled, Atari++ does not
use the AtariSIO kernel interface but rather a user space
interface, not requiring the installation of the AtariSIO
kernel module. Even though this sounds attractive, timing
cannot be as precise as for the kernel interface, and this
interface may fail if the system is under heavy load. If
AtariSIO is not compiled into the system, this is the only
possible interface method anyhow and this command line
option does not appear. Direct serial communication is then
always enabled.</p>

<p style="margin-left:11%;">-cmdtodatadelay 0..2000</p>

<p style="margin-left:22%;">only used if the
<b>directserial</b> option is enabled, this defines timing
details for the Atari SIO emulation; specifically, this is
the delay from the start of the falling edge of the
<b>COMMAND</b> line to the start of the first byte of the
command frame, given in micro seconds. According to the
Atari SIO specifications, this delay shall be between 750
and 1600 usecs long. The default is 900usecs.</p>

<p style="margin-left:11%;">-cmdframelength 800..10000</p>

<p style="margin-left:22%;">This option defines another
timing constraint of the Atari SIO <b>directserial</b>
communications protocol, namely the total length of a
command frame, from the falling to the raising edge of the
<b>COMMAND</b> line, again given in micro seconds. According
to the Atari SIO specifications, this delay shall be between
4060 and 5210usecs long, the default is here 5150usecs. Note
that due to the load of the host system some fine tuning of
this parameter might be required to get a stable SIO
communication.</p>

<p style="margin-left:11%; margin-top: 1em"><b>TAPE
Options</b> <br>
In addition to disk drives, Atari++ also supports an archaic
medium for data storage, namely the 410 and 1010 tape
drives. They store binary data in frequency-modulated form,
a high tone for a one called &ldquo;mark&rdquo; , and a
somewhat lower tone for a zero also called
&ldquo;space&rdquo;. The emulator supports two types of tape
images: First, <i>.cas</i> files, which are tape archives
that have already been converted into a binary
representation, and <i>.wav</i> files which contain the
digitized audio from the tapes directly. For the latter,
Atari++ emulates analog filters required to decode the
audio, though due to the nature of the process, <i>.wav</i>
files are less reliable, similar to real-world tape
recordings. If possible, use <i>.cas</i> files whenever
possible.</p>

<p style="margin-left:11%; margin-top: 1em">The option <br>
-image filename</p>

<p style="margin-left:22%;">defines the <i>.cas</i> or
<i>.wav</i> file to be read from or to be written to.
Atari++ accepts both the &ldquo;cas&rdquo; or
&ldquo;wav&rdquo; format as input, and can create both file
types when writing to a simulated tape. The emulator cannot
append to tape archives, i.e. each recording has to go into
a separate file.</p>

<p style="margin-left:11%;">-play bool</p>

<p style="margin-left:22%;">This option presses the
&ldquo;play&rdquo; button of the simulated tape drive and
hence allows the motor to spin if enabled by the main
system. This option does not make much sense as a command
line option but is best used within the emulator. Once the
Atari operating system beeps once, requesting you to start
the tape, enter the menu and start the tape by the button of
the same name in the <b>Tape</b> menu, then return to the
emulation and press the <b>RETURN</b> button there. This
will start the playback.</p>

<p style="margin-left:11%;">-record bool</p>

<p style="margin-left:22%;">For recording data on tape, the
Atari operating system beeps twice, requesting you to press
the &ldquo;play&rdquo; and &ldquo;record&rdquo; buttons. The
same must be done in the emulator: Go to the menu, into the
<b>Tape</b> menu, enable the &ldquo;play&rdquo; option
there, but <i>also</i> select the &ldquo;record&rdquo;
button below. The corresponding command line option is as
given above, but also makes little sense as stand-alone
option. Afterwards, return to the emulator window and press
<b>RETURN.</b> This starts the recording process. If the
&ldquo;siosound&rdquo; option is enabled, you should hear a
distinct high pitch tone that is typical for data recordings
on tape.</p>

<p style="margin-left:11%;">-eject bool</p>

<p style="margin-left:22%;">presses the simulated
eject&rdquo; button of the tape drive, removing the
recording from the drive. This unloads the image and
completes it on disk. It is most useful as a button of the
same name in the <b>Tape</b> menu as well.</p>

<p style="margin-left:11%;">-recordaswav bool</p>

<p style="margin-left:22%;">controls the output format when
recording data on tape. By default, Atari++ records in the
more robust <b>.cas</b> format which does not require
additional decoding. If this option is set, the emulator
creates <b>.wav</b> files that correspond to the audio
information that would be recorded on a real tape. This
format is not recommended for archiving purposes as it
creates longer files that are also harder to decode.</p>

<p style="margin-left:22%; margin-top: 1em">The following
additional options are also recognized by the tape
subsystem:</p>

<p style="margin-left:11%;">-videomode PAL|NTSC</p>

<p style="margin-left:22%;">defines the video mode the
system operates in, and by that the timing of the tape. This
should be, and on the command line only can be, set
identical to the video mode of the host system.</p>

<p style="margin-left:11%;">-motoroffeofgap 20..10000</p>

<p style="margin-left:22%;">controls when the emulator
considers a stopping tape as the end of the recording.
Unlike the real machine, where the tape is entirely
controlled by the user, the emulator has to make some
guessing as to when a recording should be considered as
completed, and no additional data is following. It currently
does this whenever the motor stops longer than the indicated
time, in milliseconds. The value defaults to 3000, i.e.
three seconds. Once the motor halts longer than this, the
simulated tape is removed from the tape recorder and no
further data is expected. Enlarge this value if a tape file
is created by a relatively slow BASIC program.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ATARISIO
Options</b> <br>
This option group fine tunes the AtariSIO interface whenever
it is available. Unlike the <b>SIOCABLE</b> option group,
ths set exists once per external drive and defines
parameters that are specific for the drive and not to the
cable interfacing to the drive. Therefore, the following
options exist four times, where the suffix &ldquo;.1&rdquo;
needs to be replaced by the appropriate drive number. <br>
-sioenable.1 bool</p>

<p style="margin-left:22%;">enables the first - or
subsequent for higher suffixes - external drive. It is
<b>disabled</b> by default. Note that for redirecting drive
accesses to AtariSIO, the emulator-internal drive emulation
must be disabled as well. Hence, to use a real 1050 as first
floppy drive, the following two options would be
required:</p>

<p style="margin-left:22%; margin-top: 1em">-sioenable.1
true -enable.1 false</p>

<p style="margin-left:11%;">-sioprotect.1 bool</p>

<p style="margin-left:22%;">enables or disables an
additional write-protection that blocks any write access to
the external drive as if the floppy write-protection notch
has been covered. This option defaults to <b>off.</b></p>

<p style="margin-left:11%;">-siotimeout 1..30</p>

<p style="margin-left:22%;">specifies the timeout in
seconds that applies to regular commands. Since the Atari++
emulation of the diskdrive applies at the level of raw POKEY
communcations, the emulator cannot know the desired timeout
that has been selected by the driving Atari software. This
timeout defaults to seven seconds.</p>

<p style="margin-left:11%;">-sioformattimeout 10..120</p>

<p style="margin-left:22%;">specifies the timeout in
seconds for formatting commands that typically require
longer than regular commands. This timeout defaults to sixty
seconds, i.e. one minute, but is overridden by the
specifications that are returned by the disk drive itself as
soon as a status command is send to the drive.</p>

<p style="margin-left:11%; margin-top: 1em"><b>JOYSTICK
Options</b> <br>
Joystick emulation for Atari++ consists of two layers: First
of all, the emulation of the corresponding port at the
emulated hardware, and second the generation of sigals to
feed data into this emulated port. For that, Atari++ uses
the concept of a generic <i>input device</i> consisting of
two axes and four buttons, abstracting from the real
physical device on your machine to generate the input. For a
physical (analog) PC joystick, the meaning of the two axis
and four buttons should be obvious, but other sources for
the abstract input device exist as well, e.g. the mouse or
the keyboard.</p>

<p style="margin-left:11%; margin-top: 1em">Later stages of
the Atari++ input layer then only refer to the buttons of
these virtual devices, e.g. the keypad options of the 5200
device.</p>

<p style="margin-left:11%; margin-top: 1em">The following
set of options do not control the physical input devices,
but rather select how the emulator should make use of this
abstraction layer, whereever it comes from, to form digital
joystick input. I.e. , these options control the emulation
of the emulated joystick port on input from an abstract
input device.</p>

<p style="margin-left:11%; margin-top: 1em">Similar to the
diskdrive options, all joystick options exist four times,
now numbered from zero to three. The digit behind the dot in
the option name defines the joystick port this option
controls. For the Atari 800 and 400, all four ports are used
by the emulator, for the XL and later models, only the ports
0 and 1 are mapped to the emulated hardware, similar to
their physical counterparts. <br>
-joystick.0.sensitivity 0..32767</p>

<p style="margin-left:22%;">This option sets a threshold
that must be crossed by the abstract analogue joystick input
to detect a joystick movement on the emulated joystick port.
The lower the number, the higher the sensitivity. The
abstract input devices generate axis movements from -32767
to 32767, the default of this option is that a movement of
8192 units on this scale is required to generate an input
signal.</p>

<p style="margin-left:11%;">-joystick.0.port devicename</p>

<p style="margin-left:22%;">Defines the name of the
abstract device that should be connected to the port.
Currently, the following devices exist:</p>

<p style="margin-left:17%;">MouseStick.0</p>

<p style="margin-left:28%;">Uses the mouse on your host
system as abstract input device, with the horizontal and
vertical position of the mouse pointer forming the
horizontal and vertical axis of the abstract input device
connected to the port. There is only unit 0 of this
device.</p>

<p style="margin-left:17%;">RelMouseStick.0</p>

<p style="margin-left:28%;">This works similar to the
MouseStick input device above except that reacts on mouse
movements rather than the absolute mouse coordinate. This is
often the better alternative, unless the pointer device
emulating the mouse of the host machine uses also an
absolute position, i.e. a trackpad or a touchscreen.</p>

<p style="margin-left:17%;">KeypadStick.0</p>

<p style="margin-left:28%;">Uses the keypad on the keyboard
of the host system forming the abstract input device. Digits
8,4,6 and 2 generate maximal axis movements in top, left,
right and down movement, respectively; keys 7,9,1 and 3 move
in the corresponding diagonal directions. The 0 and
<b>Enter</b> map to button 0 of the joystick. There is -
quite obviously - only unit 0 of the keypad-stick. These
keys can be reconfigured dynamically, and its configuration
is found under the section <b>KeypadStick</b> below.</p>

<p style="margin-left:17%;">AnalogJoystick.0</p>

<p style="margin-left:28%;">Uses the (real) analog joystick
connected to the port controlled by the <b>/dev/js0</b>
device to form the abstract input of the device. Which
physical axis forms which abstract axis is controlled by the
analog joystick options described below, but the default
mapping is the obvious: Each physical axis maps to the same
abstract axis, and buttons 0 and 1 map to their abstract
counterparts. Atari++ accepts up to eight physical joysticks
by replacing the digit <b>0</b> in the above option by 1 to
7 for further joysticks that are then connected to the
corresponding joystick devices.</p>

<p style="margin-left:17%;">DigitalJoystick.0</p>

<p style="margin-left:28%;">Uses a (real, antique) Atari
Joystick connected to an analog PC joystick port by means of
the &ldquo;El Cheapo&rdquo; joystick adapter of the author.
This adaptor maps the digital input lines of a digital
joystick to the buttons 1 to 4 of an analog joystick, and
maps the one and only button by a resistor array to axis 0.
As above, some parameters of this interface can be setup by
the digital joystick options described below. Similar to
above, the signals generated by this hardware are then read
thru the standard <b>/dev/js0</b> Linux interface, and up to
eight digital joysticks can be emulated this way, accessing
the devices <b>/dev/js1</b> to <b>/dev/js7. NOTE:</b> You
need to build some additional hardware to make use of this
abstract device, but you get perfect Atari feeling as a
bonus.</p>

<p style="margin-left:28%; margin-top: 1em">The schematics
for this interface are included in the distribution as
&ldquo;joystick.ps&rdquo;.</p>

<p style="margin-left:17%;">SDLAnalog.0</p>

<p style="margin-left:28%;">Similar to
&ldquo;AnalogJoystick.0&rdquo; except that the joystick
position isn&rsquo;t read from the kernel interface
directly, but rather indirectly thru the SDL library. This
makes absolutely no difference except that on some systems
only the kernel interface is available, whereas on others
only the SDL interface can be used.</p>

<p style="margin-left:17%;">SDLDigital.0</p>

<p style="margin-left:28%;">Works exactly the same as
&ldquo;DigitalJoystick.0&rdquo; except that the joystick
movements are reported thru the SDL library rather than thru
the kernel interface. Causes no difference in usage and
options otherwise.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="17%"></td>
<td width="6%">


<p>None</p></td>
<td width="5%"></td>
<td width="72%">


<p>Do not connect any device to this joystick input and
read it as &ldquo;centered, no button pressed&rdquo; all the
time.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Similar to the
diskdrive options, the joystick options exist four times
with the unit numbers <b>0</b> to <b>3.</b> The default for
the abstract input device is to use the keypad stick for
joystick zero and leave all other joysticks and paddles
unconnected.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b>
The 5200 console system does not use standard Atari digital
joystick input. Instead, analog joysticks connected to the
paddle inputs are used. It is therefore mandatory to define
the input devices of the first two paddles, paddle 0 and 1,
to have an input device for the 5200 console. The digital
joystick inputs defined by the options above <b>WILL NOT
WORK.</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>PADDLE
Options</b> <br>
The following set of options control the emulation of up to
eight paddles that can be connected to the emulator. Similar
to the above, the emulation requires an abstract input
device to read the input of the emulated paddle from; paddle
emulation uses only axis zero of this abstract device to
form the paddle input, but requires buttons zero and one for
the emulation of the two paddle buttons.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b>
The paddles on the Atari machines use the joystick input
lines for the paddle buttons. For that reason, paddles and
joysticks should not make use of the same input device.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b>
For the 5200 system, the controller is connected as a paddle
and hence these - and not the joystick options - must be
defined.</p>

<p style="margin-left:11%; margin-top: 1em">As above, the
following options exist several times, with the digit
<b>0</b> replaced by 1..7 for all other paddle units.
Whereas the Atari 800 and 400 allow this maximal number of
eight paddles, inputs 4 to 7 are not available on a real
Atari XL or XE. However, the Atari++ allows connection to
these paddle inputs regardless of the emulated host input as
the corresponding input lines are otherwise unused on the
real hardware either. <br>
-paddle.0.sensitivity 0..32767</p>

<p style="margin-left:22%;">Adjusts the sensitivity of the
paddle and hence the movement necessary for a full paddle
rotation. Note that the abstract input device generate
movements on a scale of -32767 to 32767.</p>

<p style="margin-left:11%;">-paddle.0.invert bool</p>

<p style="margin-left:22%;">Since paddle input has no
natural orientation, this option allows you to invert the
meaning of the input device position. Since some games
interpret paddle positions just opposide to others, this
flag helps you out as it changes left movement to right, or
upwards movement to downwards movement.</p>

<p style="margin-left:11%;">-paddle.0.port devicename</p>

<p style="margin-left:22%;">Defines which abstract input
device to use to feed the paddle emulation. The very same
devices as for the joystick emulation are available here,
though pure digital devices as the keyboard or the digital
joystick device are not very usable for paddle emulation.
Since an abstract input device provides two axis and two
buttons each, it makes sense to map one input device to two
paddle inputs: For that reason, each even paddle number maps
to the first axis and the first button, and each odd paddle
number maps to the second axis and button of each abstract
input device.</p>

<p style="margin-left:11%; margin-top: 1em"><b>LIGHTPEN
Options</b> <br>
Atari++ also allows emulation of the lightpen as a kind of
analog input device. Though rarely used, the corresponding
input lines at ANTIC are available and can be feed by this
emulation component. There is only one lightpen device
available, though its other options are very similar to the
paddle emulation. <br>
-lightpen.sensitivity 0..32767</p>

<p style="margin-left:22%;">Defines the sensitivity of the
lightpen and hence the factor/adjustment between the real
physical device and the emulated position of the lightpen on
the screen.</p>

<p style="margin-left:11%;">-lightpen.port devicename</p>

<p style="margin-left:22%;">Specifies which abstract input
device to connect the emulated lightpen to. The list of
available devices is identical to the list of devices for
all other gameport like input, please see the <b>JOYSTICK
Options</b> section above.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KEYPADSTICK
Options</b> <br>
Options in this group define the keys used by the
<b>Keyboard Joystick</b> emulation. By default, the numeric
keypad to the right of a standard PC keyboard is used for
this purpose, but the keys can be reconfigured. <br>
-leftup keyname</p>

<p style="margin-left:22%;">defines the key that moves the
stick in the diagonal left upwards position. Pressing the
left and the up key simultaneously is equivalent to this.
Key names are either the numbers 0 to 9 or the letters A to
Z, indicating the corresponding keys on the main keyboard,
or are taken from the list below. An empty string indicated
by an empty pair of opening and closing quotes disables the
corresponding function.</p>

<p style="margin-left:11%;">-up keyname <br>
-rightup keyname <br>
-left keyname <br>
-right keyname <br>
-leftdown keyname <br>
-down keyname <br>
-rightdown keyname</p>

<p style="margin-left:22%;">move all the joystick in the
corresponding direction. Diagonal directions can be either
assigned to separate keys, or are reached by pressing the
two direction keys simultaneously.</p>

<p style="margin-left:11%;">-center keyname</p>

<p style="margin-left:22%;">centers the joystick.</p>

<p style="margin-left:22%; margin-top: 1em">The option</p>

<p style="margin-left:11%;">-leftbutton keyname</p>

<p style="margin-left:22%;">configures the key that
emulates the left button if the keypad is used as a paddle,
or the one and only button if the keypad emulates a digital
joystick.</p>

<p style="margin-left:11%;">-rightbutton keyname</p>

<p style="margin-left:22%;">selects the key to emulate the
right button on paddles. The key has no function if the
keypad emulates a standard Atari joystick.</p>

<p style="margin-left:22%; margin-top: 1em"><b>Key
Names</b> are either alpha-numeric characters from 0 to 9 or
A to Z indicating the corresponding keys on the main
keyboard, or the following special names. Note that names
containing spaces need to be quoted on the command line:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-141942.png" alt="Image grohtml-141942.png"></p>


<p style="margin-left:11%; margin-top: 1em"><b>ANALOGJOYSTICK
Options</b> <br>
Unlike the <b>JOYSTICK Options,</b> the following set of
options describes the mapping of a true analog joystick
connected to one of the joystick device drivers to the
abstract input device that forms the basis for either
joystick, paddle or lightpen input. Hence, it defines the
layout of the <b>AnalogJoystick</b> devices that can be
connected to the above emulation components.</p>

<p style="margin-left:11%; margin-top: 1em">Similar to most
above options, the following options exist several times
with the digit <b>0</b> replaced by the unit of the
corresponding device. Hence, the analog PC joystick
controlled by <b>/dev/js1</b> is setup by options similar to
those above with a <b>1</b> replacing the <b>0.</b> <br>
-first_button 1..16</p>

<p style="margin-left:22%;">Defines which button of the
physical joystick shall map to the button zero of the
abstract input device. The default is to connect the first
button of the physical joystick to the first button, i.e.
button zero, of the abstract device. This defaults to button
#1 of the real device. If used in conjunction with the 5200
keypad device, i.e. the &ldquo;KeyButton.0.Button&rdquo; and
related options, the button index #1 used in the keyboard
configuration refers to the button addressed by this option,
and not directly to a hardware button. Thus, keypad buttons
are routed twices: In a first stage, but the hardware
abstraction layer defined by this option, and a second time
by the keyboard device picking one of the four abstract
buttons the hardware abstraction layer offers.</p>

<p style="margin-left:11%;">-second_button 1..16</p>

<p style="margin-left:22%;">Similar to the above, this
defines the real button that shall be connected to the
emulated second button of the emulated device.</p>

<p style="margin-left:11%;">-third_button 1..16</p>

<p style="margin-left:22%;">Again, this routes one of the
hardware buttons to a virtual button of the hardware
interface layer. Since the Atari hardware is only capable of
supporting at most two buttons, namely for the paddles, the
third and fourth button are only usable for the 5200 keypad
emulation, see the keyboard configuration chapter for
details.</p>

<p style="margin-left:11%;">-fourth_button 1..16</p>

<p style="margin-left:22%;">The input line of the fourth
button an abstract joystick device might support. Only
usable from the keypad emulation.</p>

<p style="margin-left:11%;">-haxis.0
xaxis.1|yaxis.1|xaxis.2|yaxis.2</p>

<p style="margin-left:22%;">Specifies the axis of the
physical joystick that should emulate the horizontal axis of
the abstract analog joystick device. The default is the
first horizontal axis of the physical joystick.</p>

<p style="margin-left:11%;">-vaxis.0
xaxis.1|yaxis.1|xaxis.2|yaxis.2</p>

<p style="margin-left:22%;">Similar to the above for the
vertical axis of the abstract device. The default is, of
course, the first vertical axis.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SDLANALOG
Options</b> <br>
This is a modified <b>AnalogJoystick</b> interface that
reads joystick positions thru the SDL library instead using
the kernel interface directly. Its configuration options are
identical to that of the <b>AnalogJoystick</b> interface and
are hence not described here again.</p>


<p style="margin-left:11%; margin-top: 1em"><b>DIGITALJOYSTICK
Options</b> <br>
The next set of options is used to setup the digital
joystick input and the &ldquo;El Cheapo&rdquo; Joystick
input adapter that can be used to connect a true Atari
digital joystick to the analog gameport input of the PC.
This option set also exists several times, once for each
available gameport detected in the host system. Once again,
replace the digit <b>0</b> by the unit number of the
corresponding device the joystick is connected to. <br>
-upbutton.0 Button.1|Button.2|Button.3|Button.3</p>

<p style="margin-left:22%;">Defines which of the four
joystick buttons on the analog gameport acts as the input
for the upwards movement line. The default is button
three.</p>

<p style="margin-left:11%;">-downbutton.0
Button.1|Button.2|Button.3|Button.3</p>

<p style="margin-left:22%;">Similar to the above for the
downwards movement. The default is button one.</p>

<p style="margin-left:11%;">-leftbutton.0
Button.1|Button.2|Button.3|Button.3</p>

<p style="margin-left:22%;">Selects the button that acts as
the left movement input. This defaults to button four.</p>

<p style="margin-left:11%;">-rightbutton.0
Button.1|Button.2|Button.3|Button.3</p>

<p style="margin-left:22%;">Selects the button for right
movement input. The default is button two.</p>

<p style="margin-left:11%;">-triggeraxis.0
XAxis.1|YAxis.1|XAxis.2|YAxis.2</p>

<p style="margin-left:22%;">Selects the analog gameport
axis that reads the digital joystick button input. The
default is that the digital fire button is connected to the
first horizontal axis.</p>

<p style="margin-left:11%;">-triggerthres.0
-32768..32768</p>

<p style="margin-left:22%;">Since the digital button is
read by the game port as an analog input, the digital signal
arrives as a numerical value between -32768 and 32767 at the
digital joystick device of the emulator. The above option
sets the threshold by which the button is read as pressed
resp. released. The precise values depend of course on the
resistance network that is connected to the analog gameport
line, but the default for 16384 works fine for the
author&rsquo;s hand-soldered adaptor.</p>

<p style="margin-left:11%;">-inverttrigger.0 bool</p>

<p style="margin-left:22%;">With this switch, the fire
button input line reading can be inverted, i.e. active
inputs are read as released fire buttons and vice versa.
This shouldn&rsquo;t be necessary with the author&rsquo;s
interface. The default is hence <b>off.</b></p>

<p style="margin-left:11%; margin-top: 1em"><b>SDLDIGITAL
Options</b> <br>
This is just a slightly modified <b>DigitalJoystick</b>
interface that connects to SDL instead to the kernel
interface. All its options are identical, please refer to
the above list for details.</p>

<p style="margin-left:11%; margin-top: 1em"><b>OSSHQSOUND
Options</b> <br>
In the following, we give a set of options to control the
generation of audio thru the OSSHQ driver, making use of the
<i>Open Sound System</i> kernel interface or an equivalent
emulation, e.g. by <i>ALSA.</i> Rather than the <b>POKEY
Options,</b> these options concern the quality of the
samples generated by the POKEY emulation and its built-up
for OSS. For audio output to work properly, you need to have
an <i>Open Sound System</i> compatible audio driver
available, and you need to have permission to access the
<i>/dev/dsp</i> device.</p>

<p style="margin-left:11%; margin-top: 1em">Note that
generating audio samples with high quality has a
non-neglectable impact on the CPU load. If your machine has
problems keeping up with the natural framerate, or if the
CPU load is too high, try to lower these settings, use a
different audio front-end, or disable sound output
alltogether. <br>
-enablesound bool</p>

<p style="margin-left:22%;">Enables or disables the
generation of audio output. The default is the enable the
audio generation, unless no audio output device is available
which then disables audio output.</p>

<p style="margin-left:11%;">-enableconsolespeaker bool</p>

<p style="margin-left:22%;">Enables or disables the
emulation of the Atari console speaker. The Atari Os
generates keyboard click sounds and the buzzer by means of
this speaker. Some games also use the console speaker for
speech output.</p>

<p style="margin-left:11%;">-consolespeakervolume 0..64</p>

<p style="margin-left:22%;">Sets the output volume of the
console speaker. Setting this to zero effectively disables
the output, and setting this to a value higher than 32 may
cause distortion with regular <b>POKEY</b> audio output.
This option ranges from zero to no up to 64 for maximal
volume with the default being 32.</p>

<p style="margin-left:11%;">-audiodevice filename</p>

<p style="margin-left:22%;">Specifies the name of the audio
device to send the samples to. This device must accept all
<i>Oss</i> specific ioct() settings. It defaults, naturally,
to <b>/dev/dsp.</b></p>

<p style="margin-left:11%;">-samplefreq 4000..48000</p>

<p style="margin-left:22%;">The sampling frequency in Hz by
which samples should be generated, and hence the limiting
frequency for the audio signals. The higher this value is,
the higher are the possible frequencies that can be
emulated, and the more natural the sound plays. Frequencies
higher than 16000 are required for software speech output,
but otherwise a frequency limit of 8000 Hz is enough for all
other sound effects. The default is 44.1kHz, the CD replay
frequency.</p>

<p style="margin-left:11%;">-fragsize 2..16</p>

<p style="margin-left:22%;">This is a technical setting
that allows to specify the size of an audio buffer fragment.
These fragments get filled sample by sample and are
transmitted to the replay hardware as soon as they are full
and the hardware is capable of playing another sample. If
they are too small, the buffer has to be refilled too often
and you might hear drop-outs since the computation cannot
keep up with the audio replay. If they are too long, the
audio latency becomes too high and the sound is no longer
synchronized with the video out. This option does, however,
not specify the fragment size itself, but rather the
exponent to the base of two, i.e the true fragment size will
be two to the power of this exponent. The default for this
option is 8, i.e. a fragment size of 256 bytes. You&rsquo;d
rarely need to play with this setting.</p>

<p style="margin-left:11%;">-numfrags 6..256</p>

<p style="margin-left:22%;">The number of buffers, each of
the size given by the above argument, to be used for audio
sample generation. More buffers reduce the likelyhood of
drop-outs, but increase the latency. The default are 16
buffers, more is rarely useful.</p>

<p style="margin-left:11%;">-forcestereo bool</p>

<p style="margin-left:22%;">Enforces to generate stereo
samples even though mono output is available for the sound
chip. Some broken sound implementations, notably ALSA on the
Emu10K1 chipset require this to work correctly under all
configuations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>OSSSOUND
Options</b> <br>
The <b>Oss</b> driver is a less complex frontend for the
<i>Open Sound System</i> audio interface, though it requires
a very precise implementation of it. Some emulations, e.g.
<i>ALSA</i> might not be suitable for this frontend, and it
rarely provides better quality than <b>HQOss.</b> Since it
provides quite similar options as well, we only describe
most of them roughly and refer to the <b>HQOss</b> frontend
for further details. <br>
-enablesound bool</p>

<p style="margin-left:22%;">Enables or disables the
generation of audio output.</p>

<p style="margin-left:11%;">-enableconsolespeaker bool</p>

<p style="margin-left:22%;">Enables or disables the
emulation of the Atari console speaker.</p>

<p style="margin-left:11%;">-consolespeakervolume 0..64</p>

<p style="margin-left:22%;">Sets the output volume of the
console speaker.</p>

<p style="margin-left:11%;">-audiodevice filename</p>

<p style="margin-left:22%;">Specifies the name of the audio
device to send the samples to; this is typically
<b>/dev/dsp.</b></p>

<p style="margin-left:11%;">-samplefreq 4000..48000</p>

<p style="margin-left:22%;">The sampling frequency in Hz
for the audio output.</p>

<p style="margin-left:11%;">-refillfreq 20..48000</p>

<p style="margin-left:22%;">The frequency in Hz by which
the audio samples are recomputed by the emulator. If this is
set to a relatively low value, but the sampling frequency is
high, then quite a lot of samples are computed in one go,
but the updating period by which these samples are matched
to the true <b>POKEY</b> output is rather low. This refill
frequency must be lower than the sampling frequency above.
For software speech generation, a refill frequency of 15700
proved most effective. For regular sound output, this
frequency can be much lower. Note that for software speech
output, the audio kernel interface must meet the
specifications of the <i>Open Sound System</i> architecture
precisely. Some emulations, e.g. <i>ALSA</i> fail here. Try
to use the <b>HQOss</b> frontend in this case; in most
cases, it is capable of providing better quality anyhow.</p>

<p style="margin-left:11%;">-fragsize 2..16</p>

<p style="margin-left:22%;">The exponent for the base of
two giving the size of an audio buffer fragment in bytes.
This is similar to the fragment size of the <b>HQOss</b>
frontend and is discussed in more detail above.</p>

<p style="margin-left:11%;">-numfrags 1..256</p>

<p style="margin-left:22%;">The number of buffers to be
used for audio sample generation. For two buffers, this
means that audio output is double-buffered. More than four
buffers are rarely useful for this driver, making this the
default.</p>

<p style="margin-left:11%;">-forcestereo bool</p>

<p style="margin-left:22%;">Enforces to generate stereo
samples even though mono output is available for the sound
chip. Some broken sound implementations, notably ALSA on the
Emu10K1 chipset require this to work correctly under all
configuations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>WAV
Options</b> <br>
The WAV frontend is the alterantive audio output module that
rather records the generated sound than to play it; or at
least, this is its main intention: WAV also offers playback
of the recorded sound, though due to timing restrictions the
quality of this sound is - sometimes noticably - worse than
that of the Oss or HQOss module and the sound that got
recorded in the final <i>.wav</i> file. As said, the quality
of the output file will be perfect. <br>
-enablerecording bool</p>

<p style="margin-left:22%;">Enables or disables the
recording to the <i>wav</i> output file. If enabled, the
emulator starts recording as soon as the emulated machine
starts running, though the recorded file is disposed and
re-written from scratch on a cold-reset, e.g. generated by
the <b>F7</b> key. To record game music, you&rsquo;d best
first enable the recording, then start the game, let the
music play and interrupt the music by entering the
configuration menu with the <b>F1</b> shortcut. Then turn
off recording. This will leave the recorded file intact.</p>

<p style="margin-left:11%;">-enableplayback bool</p>

<p style="margin-left:22%;">Enables or disables the
playback of the recorded data. If this option is enabled,
the WAV frontend will also play the music over an OSS
compatible sound driver. It is typically a good idea to
enable this option as well whenever it is available, i.e.
whenever an OSS sound driver is in the system. Note, though,
that the quality of the sound output might be of noticably
worse quality than that of the recorded sound within the
output file.</p>

<p style="margin-left:11%;">-enableconsolespeaker bool</p>

<p style="margin-left:22%;">Similar to the option of the
same name for the OSS sound front-end, this option enables
or disables the generation of sound thru the console
speaker. It is typically used for the keyboard-clicks and
the buzzer-sound.</p>

<p style="margin-left:11%;">-consolespeakervolume 0..64</p>

<p style="margin-left:22%;">Sets the volume of the console
speaker if enabled. This option defaults to 32.</p>

<p style="margin-left:11%;">-outputfile filespec</p>

<p style="margin-left:22%;">Defines the full path of the
<i>.wav</i> output file to record the sound in. If this
option is not given, then this file name defaults to
&ldquo;out.wav&rdquo;.</p>

<p style="margin-left:11%;">-audiodevice device</p>

<p style="margin-left:22%;">Sets the name of the OSS sound
device. This is typically &ldquo;/dev/dsp&rdquo;, which is
also the default setting for this option.</p>

<p style="margin-left:11%;">-samplefreq 4000..48000</p>

<p style="margin-left:22%;">Sets the sampling frequency in
Hz for the recorded <i>.wav</i> file, and by that also the
sampling frequency of the played-back audio output. The
smaller, the less CPU power is required and the shorter the
output file becomes for recording the same timespan of
music, but the worse the quality gets. This option defaults
to 15700 Hz which is the best compromise between quality and
data size. Much higher frequencies make little sense and do
not improve quality noticably.</p>

<p style="margin-left:11%;">-fragsize 2..16</p>

<p style="margin-left:22%;">sets similar to the OSS
front-end option of the same name the exponent for the size
of the fragment for audio playback. It has no influence
whatsoever on the output file whatsoever, but rather
modifies the behaivour of audio playback only.</p>

<p style="margin-left:11%;">-numfrags 1..256</p>

<p style="margin-left:22%;">sets the number of audio
fragments (buffers) for audio playback, similar to the
option of the same name of the OSS front-end. It has no
influence on the recorded samples.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SDLSound
Options</b> <br>
The next audio front-end is generation thru the <i>Standard
Direct Media Library,</i> or short <i>SDL,</i> all provided
you have an SDL library and the required development files
installed on your host. The quality of the SDL output is
close to that of the <b>HQOss</b> frontend, though due to
the different driver architecture, it is unfortunately more
likely for the SDL driver to generate drop-outs. It
furthermore requires longer fragments and has therefore a
higher latency, but it is very portable as SDL exists on a
variety of platforms. <br>
-enablesound bool</p>

<p style="margin-left:22%;">enables or disables the sound
generation thru SDL, similar to the same option for the OSS
and WAV audio front-ends.</p>

<p style="margin-left:11%;">-enableconsolespeaker bool</p>

<p style="margin-left:22%;">will toggle the console speaker
emulation on or off. The emulation is enabled by
default.</p>

<p style="margin-left:11%;">-consolespeakervolume 0..64</p>

<p style="margin-left:22%;">adjusts the volume of the
console speaker. This setting defaults to a medium volume of
32.</p>

<p style="margin-left:11%;">-samplefreq 4000..48000</p>

<p style="margin-left:22%;">adjusts the sampling frequency
for the audio generation in Hz = samples per second. Higher
sampling frequencies provide closer sound output emulation,
but also enlarge the CPU load on the system. The sampling
frequency defaults to 44100Hz, i.e. CD quality. You might
have to lower this setting on weaker systems.</p>

<p style="margin-left:11%;">-fragsize 2..16</p>

<p style="margin-left:22%;">selects the size of an audio
output buffer as the exponent for the base of two. The
smaller the fragment size, the more often the audio output
will get updated to reflect the audio register setting of
the POKEY chip, and the more natural audio output will
become. If the fragment size is too small, then audio output
will degrate quickly, though, as the emulation will then no
longer be able to refill the output buffers in time. The
optimal setting for this value is around nine, which is also
the default.</p>

<p style="margin-left:11%;">-forcestereo bool</p>

<p style="margin-left:22%;">Enforces to generate stereo
samples even though mono output is available for the sound
chip. Some broken sound implementations, notably ALSA on the
Emu10K1 chipset require this to work correctly under all
configuations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>DirectX
Sound Options</b> <br>
This audio front-end is only available for win32 compatible
platforms and requires at least DirectX 8.0 installed on the
host machine. It offers the highest audio quality available
under the win32 operating system at minimal latency.</p>

<p style="margin-left:11%; margin-top: 1em">The following
options are available for DIRECTX sound: <br>
-enablesound bool</p>

<p style="margin-left:22%;">enables or disables audio
output. It is enabled by default.</p>

<p style="margin-left:11%;">-enableconsolespeaker bool</p>

<p style="margin-left:22%;">turns emulation of the console
speaker on or off. This speaker generates the keyboard click
and buzzer sounds, but is otherwise not very frequently
used; it is enabled by default.</p>

<p style="margin-left:11%;">-consolespeakervolume 0..64</p>

<p style="margin-left:22%;">controls the volume of the
console speaker. The default setting is 32, though higher
volumes are not recommended as they will cause distortion
when mixing them with the regular POKEY output.</p>

<p style="margin-left:11%;">-samplefreq 4000..48000</p>

<p style="margin-left:22%;">selects the sampling frequency
in samples per second. The default is 22050 Hz, i.e. half
the frequency of an audio CD. Higher frequencies are not
recommended for DirectX as the CPU load gets very high
otherwise.</p>

<p style="margin-left:11%;">-fragsize 2..12</p>

<p style="margin-left:22%;">sets the size of one audio
buffer, also called a &ldquo;fragment&rdquo; by defining its
exponent to the base of two. Thus, increasing this setting
by one doubles the size of one audio buffer, a setting of
eight causes buffers that are 2^8 = 256 samples long. This
is also the default buffer setting and a good compromize
between latency and quality for fast, up-to-date hardware.
Slower systems might require higher values; in case you hear
audio drop-outs, increase this value.</p>

<p style="margin-left:11%;">-numfrags 6..16</p>

<p style="margin-left:22%;">defines the number of audio
buffers of the above size to be allocated. A higher number
will allocate more buffers, causing higher latency, but also
lowering the probability of drop-outs. The default are six
buffers, but this number should be increased in case the
audio output isn&rsquo;t smooth.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ALSASound
Options</b> <br>
The last available audio front-end uses the ALSA sound
drivers available on Linux and the <b>asoundlib</b> API.
Both, and their development files must be available at
compile time to provide this interface.</p>

<p style="margin-left:11%; margin-top: 1em">If available,
ALSA provides a high quality sound similar to the
<b>HQOSS</b> frontend, though its demands concerning the CPU
power are very moderate and lower than that of other
frontends.</p>

<p style="margin-left:11%; margin-top: 1em">The following
options are available for ALSA: <br>
-enablesound bool</p>

<p style="margin-left:22%;">enables or disables the sound
output. This defaults to on.</p>

<p style="margin-left:11%;">-enableconsolespeaker bool</p>

<p style="margin-left:22%;">controls emulation of the
console speaker; this option is turned on by default.</p>

<p style="margin-left:11%;">-consolespeakervolumne
0..64</p>

<p style="margin-left:22%;">selects the volume of the
console speaker. It is set to 32 by default; higher volumes
might cause distortion in the sound output.</p>

<p style="margin-left:11%;">-audiocard name</p>

<p style="margin-left:22%;">selects the audio hardware ALSA
shall sent the samples to. This is <b>not</b> a device
specification in the sense of a path name. It defaults to
&ldquo;hw:0,0&rdquo; which addresses the first available
audio hardware that is handled by ALSA. Further audio cards
are named &ldquo;hw:1,0&rdquo; and so on. Even though
Atari++ supports a wide range of sampling formats natively,
some exotic cards might require the help by ALSA. To enable
this additional software support, substitute
&ldquo;hw&rdquo; by &ldquo;plughw&rdquo;, e.g. specify
&ldquo;plughw:1,0&rdquo; as device name. This enables an
additional software conversion inside ALSA.</p>

<p style="margin-left:11%;">-samplefreq 4000..48000</p>

<p style="margin-left:22%;">selects the sampling frequency
in samples per second. The default is 44100 Hz, i.e. CD
quality.</p>

<p style="margin-left:11%;">-fragsize 2..16</p>

<p style="margin-left:22%;">defines the size of an audio
buffer fragment as the exponent to the base of two. This
works very similar to all other audio frontends and is not
explained here again. ALSA allows a relatively small default
of 8 here, meaning fragments of 2^8 = 256 bytes.</p>

<p style="margin-left:11%;">-numfrags 6..256</p>

<p style="margin-left:22%;">defines the size of the audio
buffer in fragments. The more fragments, the lower the
probability of drop-outs but the higher the latency. The
number of fragments defaults to 12.</p>

<p style="margin-left:11%;">-forcestereo bool</p>

<p style="margin-left:22%;">Enforces to generate stereo
samples even though mono output is available for the sound
chip. Some broken sound implementations, notably ALSA on the
Emu10K1 chipset, may require this to work correctly under
all configuations.</p>

<p style="margin-left:11%; margin-top: 1em"><b>X11
Options</b> <br>
The next set of options controls the <i>X11</i> graphical
frontend of the Atari++ emulator, all provided it has been
selected with the <b>-frontend X11</b> option. Otherwise,
the control options of the selected frontend apply instead.
<br>
-privatecmap bool</p>

<p style="margin-left:22%;">If set to <b>on,</b> then
Atari++ will emulate its own color map for the emulation
window output. This is only required if you run it on a 8
bit display and the emulator further complains that it
couldn&rsquo;t allocate enough free pens. The downside of
this option is that the colors will get wrong as soon as the
mouse pointer leaves the emulator window on an 8 bpp
display, but at least you get a display with proper colors
otherwise.</p>

<p style="margin-left:22%; margin-top: 1em">This option is
not at all useful for 16 bpp or any other true-color
displays as the color mapping will be correct all the time
otherwise. Therefore, the default for this option is
<b>off.</b></p>

<p style="margin-left:11%;">-syncx bool</p>

<p style="margin-left:22%;">A boolean flag that describes
whether the X11 frontend shall try to keep the display
output in sync with the emulator. If set to <b>off,</b> all
rendering operations will be asynchronous, possibly causing
some lag between the gameplay and the display. The downside
of enforcing synchronous graphic renderning by setting this
to <b>on</b> is that the display refresh must wait for the X
server to perform the refresh and to notify the client about
it, adding the turn-around times and the net transfer
overhead to the display refresh time. It is therefore rarely
a good idea to enable this option.</p>

<p style="margin-left:11%;">-disableDPMS</p>

<p style="margin-left:22%;">disables the display management
power signal extension and thus prevents the monitor blanker
or screen safer of the operating system to jump in while
playing with the emulator. It is usually a good idea to
enable this option.</p>

<p style="margin-left:11%;">-xvideorendering bool</p>

<p style="margin-left:22%;">will use the
&ldquo;XVideo&rdquo; extension of the X11 system to render
graphics on the screen. Unlike the default rendering mode
which builts the image from many colored rectangles, this
render mode writes the raw display data into a shared memory
region which is then scaled and pushed to the screen
directly by the video overlay mechanism of the graphics card
when available. Depending on the graphics hardware, this
option may provide better performance on lower end
hardware.</p>

<p style="margin-left:11%;">-renderindirect bool</p>

<p style="margin-left:22%;">If set to <b>on,</b> then all
rendering happens indirectly to an off-screen pixmap in a
first step, then blitting the pixmap in a second step back
to the screen. This has the downside of being slower by
requiring an additional transfer step, but it makes the
display refresh smoother as well as the rendering operation
itself remains invisible. Since it makes emulation slower,
this option remains <b>off</b> by default.</p>

<p style="margin-left:11%;">-screenbase filename</p>

<p style="margin-left:22%;">Selects a filename base for the
screen dumps. If a screendump is requested, a counter and a
file type extender is appended to this name and the screen
contents are saved to this file. Currently, screen dumps are
saved in the <i>Portable Pixmap (ppm) Format</i> that is
readable by most Linux/Unix tools, e.g. by xv and gimp. The
default filename is &ldquo;ScreenDump&rdquo;.</p>

<p style="margin-left:11%;">-dumpformat PNM|BMP|PNG</p>

<p style="margin-left:22%;">Specifies the file format to be
used for screen dumps. <i>PNM</i> is the simplistic *nix
specific PNM/PPM true color dump file format that is
understood by most *nix programs. <i>BMP</i> is the Windows
Bitmap format, a very popular but rather aged image file
format of the Win world. <i>PNG</i> is the &ldquo;Portable
Network Graphics&rdquo; file format, an image format driven
forward by the Open Source community. This file format
requires the availibility of the LibPNG.</p>

<p style="margin-left:11%;">-pixelwidth 1..8</p>

<p style="margin-left:22%;">This option spezifies the
magnification degree in horizontal direction by which the
pixels of the emulated scren are rendered to the X11
display. The default of the pixelsize option is <b>2,</b>
i.e. a single pixel of the Atari display is rendered twice
as large on the X window showing the emulation. Depending on
the hardware driver of your graphics board, enlarging the
pixelsize might be almost for free with the X11
frontend.</p>

<p style="margin-left:11%;">-pixelheight 1..8</p>

<p style="margin-left:22%;">This option controls the
magnification of the pixel size in vertical direction,
similar to the above option the default value is
<b>2.</b></p>

<p style="margin-left:11%;">-leftedge 0..64</p>

<p style="margin-left:22%;">Sets the horizontal position of
the first Atari pixel that gets displayed within the X11
window. The pixels left to this pixel are not made visible.
This option is useful either to align the size of the X
window to the natural size of the screen the window is
contained in, to hide the leftmost pixel junk caused by the
horizontal ANTIC scrolling, or to remove the hardware border
of the window, similar to the operation performed by some
TVs. This option defaults to 16, just enough to make the
<b>HSCROLL</b> artefacts invisible.</p>

<p style="margin-left:11%;">-topedge 0..64</p>

<p style="margin-left:22%;">Sets the first row of the ANTIC
display to render to the X11 window. This is otherwise
identical to the -leftedge option except that it works in
vertical direction. The default of this option is zero.</p>

<p style="margin-left:11%;">-width 320..480</p>

<p style="margin-left:22%;">Sets the total amount of pixels
to render into the screen and hence the inner dimension of
the X window. Reducing this width can be either useful to
fit this window into the screen, or to avoid some pixel junk
at the right edge of the ANTIC display. The default width is
352 pixels.</p>

<p style="margin-left:11%;">-height 192..248</p>

<p style="margin-left:22%;">Sets the height of the window
in emulated pixels. Since the lowest lines are always left
blank anyhow, they need not to be rendered. Therefore, this
option defaults to 240.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SDL
Options</b> <br>
The next option set controls the layout of the alternate
emulator frontend driven by the <b>Simple Direct Media
Library,</b> or short, SDL. This library allows fullscreen
output, though its overall performance is lower as soon as
it requires to upscale the pixels. The SDL frontend is
activated by the <b>-frontend SDL</b> switch, and only then
the following options apply: <br>
-leftedge 0..64</p>

<p style="margin-left:22%;">Similar to the <i>X11</i>
Option of the same name, this selects the first visible
emulator pixel on the SDL screen. This option defaults to
16.</p>

<p style="margin-left:11%;">-topedge 0..64</p>

<p style="margin-left:22%;">Specifies the first visible row
on the screen. The default is to start the display at row
0.</p>

<p style="margin-left:11%;">-width 320..480</p>

<p style="margin-left:22%;">The width in emulator pixels of
the screen to render. The default is 352.</p>

<p style="margin-left:11%;">-height 192..248</p>

<p style="margin-left:22%;">The height of the emulated
display. The default is to drop some lines at the bottom end
since they are always blank anyhow: 240 lines are rendered
by default.</p>

<p style="margin-left:11%;">-pixelwidth 1..8</p>

<p style="margin-left:22%;">Set the width of one emulator
pixel in SDL pixels. The default is that one emulator pixel
is represented by one pixel on the SDL screen. Setting this
to values larger than two easely degrades the emulator
performance.</p>

<p style="margin-left:11%;">-pixelheight 1..8</p>

<p style="margin-left:22%;">Set the height of one emulator
pixel in SDL pixels. As already said above, the default is
one. Pixel heights larger than two typically slow down the
emulator too much to be useful.</p>

<p style="margin-left:11%;">-screenbase filename</p>

<p style="margin-left:22%;">Defines a base file name
similar to the <b>X11</b> screenbase option for screen
dumps. The filename of the screen dump is, as above, formed
by a counting number and the extender of the file format.
Currently, screen snapshots are saved as PPM images.</p>

<p style="margin-left:11%;">-doublebuffer bool</p>

<p style="margin-left:22%;">enables double buffering,
provided the implementation of SDL on the host system
implements it. Double buffering allows smoother scrolling at
the price of a slightly higher CPU load. At the time of
writing, only the win32 version of SDL provides double
buffering, the Linux version does not. Thus, enabling this
option under Linux does nothing. However, the
<b>renderindirect</b> option of the <b>X11</b> front-end
does something very similar.</p>

<p style="margin-left:11%;">-fullscreen bool</p>

<p style="margin-left:22%;">Enables or disables full screen
display. The default is to use the full screen display, and
it is recommended to use the <b>X11</b> frontend otherwise
as it provides higher performance in this case.</p>

<p style="margin-left:11%;">-dumpformat PNM|BMP|PNG</p>

<p style="margin-left:22%;">Specifies the file format to be
used for screen dumps. <i>PNM</i> is the simplistic *nix
specific PNM/PPM true color dump file format that is
understood by most *nix programs. <i>BMP</i> is the Windows
Bitmap format, a very popular but rather aged image file
format of the Win32 world. <i>PNG</i> is the &ldquo;Portable
Network Graphics&rdquo; file format, an image format driven
forward by the Open Source community. This file format
requires the availibility of the LibPNG.</p>

<p style="margin-left:11%;">-shieldcursor bool</p>

<p style="margin-left:22%;">Enables a workaround against an
SDL bug that allows a program to overdraw the active mouse
pointer, trashing its backing store and leaving invalid
graphics behind the pointer if it is moved away. This
workaround will remove the cursor prior the drawing
operation to avoid the problem, at the cost of a possibly
flickering pointer.</p>

<p style="margin-left:11%;">-deblocker bool</p>

<p style="margin-left:22%;">Enables a deblocking filter
that creates rounder and smoother graphics for pixel sizes
between two and three. This avoids to some degree the
blocky-ness of the emulated display that is caused by the
higher and finer resolution of the PC monitor compared to
the TV output the Atari hardware was designed for.</p>


<p style="margin-left:11%; margin-top: 1em"><b>850INTERFACE
Options</b> <br>
The Atari++ contains a complete emulation of the 850 serial
interface box, including a boot-able R: handler that would
be usually included in the ROM of the interface box. The
emulation allows you to use the serial port of the host
system as a serial output port of the 850 interface,
allowing you to connect a modem to the emulated Atari. The
emulation has only two limitations: For first, it cannot
provide some of the exotic baud rates the 850 box is able to
generate, and it provides only a single serial port, not
four of them. On the other hand, it offers a true hardware
handshake, unlike the Atari 850. For more information about
the emulator provided R: handler, see below.</p>

<p style="margin-left:11%; margin-top: 1em">The following
options configure the 850 emulation: <br>
-enable850 bool</p>

<p style="margin-left:22%;">Enables or disables the 850
interface. If disabled, the interface box will not react on
any SIO commands and will hence pretend to be turned
off.</p>

<p style="margin-left:11%;">-serialname path</p>

<p style="margin-left:22%;">Specifies the device name for
the serial port the emulated 850 interface shall use as its
output port. The default device name is
&ldquo;/dev/ttyS0&rdquo;, i.e. the first serial output port
of the system.</p>

<h2>CONFIGURATION FILES
<a name="CONFIGURATION FILES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Atari++ is not
only controlled by its huge amount of command line
parameters. It is also adjustable by configuration files.
These configuration files contain the very same options than
the command line parameters, except that there is only one
option per line, an equals = sign separates option from
value, and the minus-sign in front of the option is missing.
Additionally, empty lines and comments starting with the
hash-mark # are allowed. The following example shows a
typical configuration file:</p>

<p style="margin-left:11%; margin-top: 1em"># <br>
# This is the config file for the atari++ emulator <br>
# <br>
HoldOption = true <br>
Artefacts = off <br>
Enable.1 = on <br>
Protect.1 = on <br>
SIOPatch = on <br>
InstallPDevice = on <br>
SampleFreq = 44100 <br>
RefillFreq = 15700 <br>
NumFrags = 4 <br>
Joystick.0.Port = DigitalJoystick.0</p>

<p style="margin-left:11%; margin-top: 1em">The Atari++
emulator knows three configuration files: The system
specific configuration file, residing at
/etc/atari++/atari++.conf, the per-user specific
configuration file at ~/.atari++.conf and the per-directory
configuration file at ./.atari++.conf. Each later
configuration file overloads the defaults of the former, and
the command line arguments finally overload all of them.
This way, the least frequently adjusted options should go
into the configuration file in the home directory, with
system specific settings in /etc.</p>

<h2>KEYMAP
<a name="KEYMAP"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Atari++
emulator uses the following keymap:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>F1</p></td>
<td width="7%"></td>
<td width="78%">


<p>This key enters the graphical configuration menu. The
usage of this menu should be quite obvious as all the
options are named as in this manual and sorted under the
same topics. The menu is left by the topmost <b>Prefs</b>
topic which also allows loading and saving the settings and
entering the monitor. The <b>F1</b> key changes its meaning
for the CURSES front-end, where no full menu is available.
Here, it replaces the Atari resp. inverse-video key.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>F2</p></td>
<td width="7%"></td>
<td width="78%">


<p>is mapped to the <b>Option</b> console key.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>F3</p></td>
<td width="7%"></td>
<td width="78%">


<p>is mapped to the <b>Select</b> console key.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>F4</p></td>
<td width="7%"></td>
<td width="78%">


<p>is mapped to the <b>Start</b> console key.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>F5</p></td>
<td width="7%"></td>
<td width="78%">


<p>is the <b>Help</b> key that is otherwise only available
on the XL and XE hardware.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>F6</p></td>
<td width="7%"></td>
<td width="78%">


<p>is the <b>Reset</b> console key. Its function differs a
bit amongst various models. For the Atari 800 and 400, this
key just signals a special NMI interrupt at ANTIC, and the
Os resets the system manually. For the XL and XE, this
signal is really connected to the CPU reset line. Atari++
emulates this behaivour.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>F7</p></td>
<td width="7%"></td>
<td width="78%">


<p>coldstarts the system as if it has been turned off and
on again. Hence, unlike F6, this is a true coldstart and not
a warmstart.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>F8</p></td>
<td width="7%"></td>
<td width="78%">


<p>emulates the <b>Break</b> key, used to stop listings and
BASIC programs.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>F9</p></td>
<td width="7%"></td>
<td width="78%">


<p>requests a screen dump. Where this screendump goes is a
matter of the <i>-screenbase</i> command line option.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>F10</p></td>
<td width="7%"></td>
<td width="78%">


<p>aborts the emulator immediately, similar to closing the
window.</p> </td></tr>
</table>

<p style="margin-left:11%;">F11 and Pause</p>

<p style="margin-left:22%;">pauses the emulator. Pressing
<b>F11</b> again continues the emulation.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>F12</p></td>
<td width="7%"></td>
<td width="78%">


<p>enters the on-line monitor that is described below.</p></td></tr>
</table>

<p style="margin-left:11%;">Home/Clear</p>

<p style="margin-left:22%;">emulate the <b>Shift+&lt;</b>
sequence, enforcing a clear screen.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>Insert</p></td>
<td width="2%"></td>
<td width="78%">


<p>inserts a blank character under the cursor by emulating
<b>Ctrl+&gt;.</b> If pressed together with <b>shift,</b> a
blank line is inserted at the current line position.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>Del</p></td>
<td width="2%"></td>
<td width="78%">


<p>removes a single character under the cursor by emulating
a <b>Ctrl+BS</b> keyboard sequence.</p></td></tr>
</table>

<p style="margin-left:11%;">Cursor Keys</p>

<p style="margin-left:22%;">move the cursor in the
indicating direction by holding either <b>+,*,-,=</b> and
the <b>Ctrl</b> key down. This works fine most the time
except for the <i>DDT</i> debugger which requires these keys
pressed without <b>Ctrl</b> for window movement. Do not use
the separate cursor keys but the above keys directly for
DDT.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>Esc</p></td>
<td width="7%"></td>
<td width="78%">


<p>emulates, as expected, the <b>ESC</b> key on the Atari
keypad.</p> </td></tr>
</table>

<p style="margin-left:11%;">Keypad keys
7,8,9,4,5,6,1,2,3</p>

<p style="margin-left:22%;">are part of the
&ldquo;keypadstick.0&rdquo; device and a possible emulation
source for joystick input; they are also configurable, see
the <b>KeypadStick</b> section.</p>

<p style="margin-left:11%;">Keypad keys 0 and Enter</p>

<p style="margin-left:22%;">emulate the joystick button of
the device as well.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>ALT</p></td>
<td width="7%"></td>
<td width="78%">


<p>emulates the <b>Atari</b> or <b>InverseVideo</b> key.
For some implementations, this key is also emulated by the
<b>Windows</b> key.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">All other keys
have their natural key binding except for the 5200 game
console which is explained below. This binding is given by
the current keyboard layout; this means especially that the
keyboard layout is language specific and does not
necessarely match the layout of the Atari keyboard. E.g. for
a german keyboard, the keys for &ldquo;y&rdquo; and
&ldquo;z&rdquo; work as printed on the PC keyboard, and not
as for the (american) Atari keyboard layout. I currently
consider this as an advantage.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KEYBOARD
INPUT FOR THE 5200</b> <br>
Keyboard input on the 5200 game system is considerably
different as this console does not have a keyboard, but a
small numberic pad on each of its controllers. This pad
consists of the numbers zero to nine, the asterisk
&ldquo;*&rdquo;, the hash-mark &ldquo;#&rdquo; and the
buttons labelled &ldquo;Start&rdquo;, &ldquo;Pause&rdquo;
and &ldquo;Reset&rdquo;. Furthermore, the joysticks have two
buttons instead of one, and are actually analog joysticks
using the paddle input lines, see above. The current
emulator uses the PC keyboard for all additional keys and
does currently not distinguish between the various keypads.
A button pressed on the PC keyboard will be read as coming
from all game controllers at once. A future version of
<i>atari++</i> may possibly use a different scheme.</p>

<p style="margin-left:11%; margin-top: 1em">The following
keyboard keys act differently on the 5200 system:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">F2</p></td>
<td width="8%"></td>
<td width="78%">


<p style="margin-top: 1em">is the &ldquo;Reset&rdquo; key
on the keypad of the controller. This key is in no way any
kind of hardware reset and is dissimilar to the
&ldquo;real&rdquo; hardware reset which is still triggered
by <b>F6.</b> Instead, this key is just an ordinary key that
must be read by the loaded game, typically bringing you back
to the setup screen.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>F3</p></td>
<td width="8%"></td>
<td width="78%">


<p>is the &ldquo;Pause&rdquo; key on the keypad. This is
also a purely software driven feature the game may or may
not support.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>F4</p></td>
<td width="8%"></td>
<td width="78%">


<p>is the &ldquo;Start&rdquo; key; it typically launches
the game.</p></td></tr>
</table>

<p style="margin-left:11%;">keys 0..9</p>

<p style="margin-left:22%;">activate the corresponding
keypad keys.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>H or #</p></td>
<td width="2%"></td>
<td width="78%">


<p>emulates the hash-mark on the keypad controller key.
Since the hashmark is not available on all native PC
keyboards, the <b>H</b> is available as an replacement.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>S or *</p></td>
<td width="2%"></td>
<td width="78%">


<p>emulates the asterisk on the controller keypad.
Similarly, the <b>S</b> is a suitable emulation for native
keyboards with a hard-to-reach asterisk key.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>Shift</p></td>
<td width="2%"></td>
<td width="78%">


<p>acts as the second trigger button on all external
controller keypads.</p></td></tr>
</table>

<p style="margin-left:11%;">F2 thru F12</p>

<p style="margin-left:22%;">act as usual, see the list
above.</p>

<p style="margin-left:11%;">all other keys</p>

<p style="margin-left:22%;">are blind and perform no
operation in the 5200 emulation mode.</p>

<h2>THE CURSES EMULATION
<a name="THE CURSES EMULATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The keyboard
input of the <b>CURSES</b> (terminal) front-end is rather
limited because the emulator has considerably less control
over the keyboard than under the graphical front-ends. Note
that this emulation replaces the complete front-end of the
emulator, it is not fit to script it, e.g. feed input to it
from a file. For that, better replace operating system
editor functions and use the <b>InstallEDevice</b>
function.</p>

<p style="margin-left:11%; margin-top: 1em">In the curses
front-end, most keys work as expected, with some
limitations:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p>F1</p></td>
<td width="5%"></td>
<td width="78%">


<p>does not provide a full menu, which is not available due
to lack of graphics output. Instead, the machine must be
configured manually from the command line or the
configuration files. The <b>F1</b> key rather maps to the
<b>Atari</b> or <b>InverseVideo</b> key as the state of the
<b>ALT</b> key is not directly accessible from the CURSES
interface.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="6%">


<p>CAPS</p></td>
<td width="5%"></td>
<td width="78%">


<p>is not directly available because the CapsLock key is
read by the host operating system and is not forwarded to
the emulation. Instead, the emulator sends a <b>CAPS</b> key
event after each reset, triggering the system to low-caps,
which is the default under most host operating systems, and
then setting the <b>Shift</b> key of the emulated machine
according to the case of the inserted character. This makes
<b>CAPS</b> &ldquo;appear&rdquo; to work right for most
situations, unless a program fiddles with the operating
system and alters the <b>CAPS</b> state manually, or
performs a software-driven reset. In this case, the <b>ASCII
TILDE</b> that is &ldquo; <b>~</b> &rdquo; will emulate a
press on the <b>CAPS</b> key of the host.</p></td></tr>
</table>

<p style="margin-left:11%;">Requesters and Menus</p>

<p style="margin-left:22%;">Requesters and error messages
will be emulated on the console by text-driven menus,
allowing you to select a choice by typing the indicated
character.</p>

<p style="margin-left:11%;">Graphics Output</p>

<p style="margin-left:22%;">The graphics emulation is
limited to text based ANTIC modes, limited to the standard
character set. Some of the text graphics can be emulated,
ASCII-Art might work to a limited degree, but bitmap
graphics output will not appear on the console. Some limited
support for horizontal scrolling is available, though.</p>

<h2>SNAPSHOT FILES
<a name="SNAPSHOT FILES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The atari++
allows you to make a snapshot of the complete machine state
anytime within a game, to save this state to a file and to
restart the game later on from this position. This is not
only useful to interrupt a game temporarely - maybe because
you&rsquo;ve better things to do in the mean time - it also
helps to try hard game puzzles several times.</p>

<p style="margin-left:11%; margin-top: 1em">To create a
snapshot file, enter the menu by pressing the <b>F1</b> key
on your keyboard, pick the <b>Prefs</b> item on the left
hand side list and enter the name of the state file into the
bottommost gadget labelled &ldquo;Save State To&rdquo;.</p>

<p style="margin-left:11%; margin-top: 1em">To restore a
machine state, i.e. to load the snapshot file, use the
gadget &ldquo;Load State From&rdquo; right on top of it, or
the command line option <b>-state filename</b> expecting the
name of your snapshot file.</p>

<p style="margin-left:11%; margin-top: 1em">It is important
to understand that the snapshot file contains only the part
of the inner machine state that <b>is not covered by the
configuration file.</b> For example, the snapshot file will
<b>NOT</b> contain the currently active ROM image as this
image is already sufficiently specified by the
configuration. Hence, if your configuration at the time you
made the snapshot differs from your default configuration,
you should also save that configuration, and load it along
with the snapshot. <b>Snapshot files extend configuration
files,</b> they are not independent from the emulator
configuration.</p>

<h2>THE H: HANDLER
<a name="THE H: HANDLER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The emulator
provides an optional interface from the emulated Atari to
the host environment by the <b>H:</b> handler that makes
parts of the filing system of the host visible within the
emulation. To make use of this handler, it has to be enabled
by the <b>-InstallHDevice on</b> command line option or a
similar option within the configuration files. This option
will replace the <b>C:</b> cassette interface - which is
rarely, if ever, useful - by the host interface filehandler.
This handler provides four units, named <b>H1:</b> to
<b>H4:</b> opening four directories of the host system
within the emulator. These directories are configured by the
<b>-H1Dir</b> to <b>-H4Dir</b> command line options,
expecting path name(s) to host system directories.</p>

<p style="margin-left:11%; margin-top: 1em"><b>FILE NAMES
AND PATTERN MATCHING</b> <br>
Similar to the standard file management systems DOS 2.0S and
upper, the <b>H:</b> handler automatically resolves patterns
within filenames. The following wildcards are supported:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>*</p></td>
<td width="10%"></td>
<td width="78%">


<p>matches a sequence of any, possibly zero, length of any
characters, quite similar to the bash or the csh.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>?</p></td>
<td width="10%"></td>
<td width="78%">


<p>matches one single character.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>-</p></td>
<td width="10%"></td>
<td width="78%">


<p>Matches any character and ignores the rest of the
pattern.</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Unlike the
standard file management systems, the dot &ldquo;.&rdquo;
has no special meaning for the <b>H:</b> device except that
file names are truncated to eigth characters in front and
three characters beyond it. This is a backwards
compatibility feature to be able to run most Atari Os
compliant programs on the <b>H:</b> device without
additions.</p>

<p style="margin-left:22%; margin-top: 1em">The handler
will furthermore ignore cases when comparing the requested
file name with a file name on the host system. Files
generated by the emulator will use lower case for
convenience.</p>

<p style="margin-left:11%; margin-top: 1em"><b>COMMAND
SET</b> <br>
The <b>H:</b> handler supports the following IO commands:
<br>
CMD 3: OPEN</p>

<p style="margin-left:22%;">used by the BASIC <i>OPEN
#channel,aux1,aux2,&ldquo;H:filespec&rdquo;</i> command. The
<i>aux2</i> specifier will be ignored, valid <i>aux1</i>
values are:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-141943.png" alt="Image grohtml-141943.png"></p>

<p style="margin-left:22%; margin-top: 1em">This follows
closely the DOS 2.0S conventions with the addition that mode
12 is able to write past EOF and mode 13 also creates files.
Mode 7 is an addition that was made for compatibility of DOS
2.XL by the author.</p>

<p style="margin-left:22%; margin-top: 1em">The
<i>filespec</i> follows the file name convention explained
in the previous subsection; the directory listing generated
by codes 6 and 7 will be formatted similar to the DOS 2.0S
output for the same request, but the amount of free sectors
will always show up as &ldquo;999&rdquo;. This is because
there is basically no visual storage limit for a tiny Atari
file system inside a Unix/Linux workstation. Files that are
not user-writeable appear as &ldquo;locked&rdquo; and are
marked with an asterisk in the first column. Similarly, file
locking and unlocking changes the user-writeable protection
bit of the host system.</p>

<p style="margin-left:11%;">CMD 5: GET RECORD</p>

<p style="margin-left:22%;">Reads characters up to an
<b>EOL</b> character, or up to the buffer end, into a
buffer. This is a standard command supplied by all handlers.
This implements the BASIC <i>INPUT #channel,var</i> and
related commands.</p>

<p style="margin-left:11%;">CMD 7: GET CHARACTERS</p>

<p style="margin-left:22%;">Reads a block of characters
into a buffer. This is a standard command, consult the Atari
technical manual for details. Not reachable from BASIC.</p>

<p style="margin-left:11%;">CMD 9: PUT RECORD</p>

<p style="margin-left:22%;">Writes characters up to an
<b>EOL</b> or up to the end of the buffer into the opened
stream. Also part of the standard command set. Not reachable
from BASIC, but related to the BASIC command <i>PRINT
#channel,data.</i></p>

<p style="margin-left:11%;">CMD 11: PUT CHARACTERS</p>

<p style="margin-left:22%;">Writes a block of characters
into a stream. A standard command. Not reachable within
BASIC, but related to the BASIC commands <i>PUT
#channel,value</i> and <i>PRINT #channel,data.</i></p>

<p style="margin-left:11%;">CMD 12: CLOSE</p>

<p style="margin-left:22%;">Releases the given stream,
closes the file on the host system and frees all buffers.
This command is considered harmless on streams already
closed. This implements the BASIC <i>CLOSE #channel</i>
command.</p>

<p style="margin-left:11%;">CMD 13: STATUS</p>

<p style="margin-left:22%;">Requests the status of the
given stream. It returns status code 133 if the channel is
not open, status code 1 if the channel generated no error,
status code 3 if you are about to read from the <b>EOF</b>
on the next go, or the last error should the stream be in an
error condition otherwise. This follows standard
conventions.</p>

<p style="margin-left:11%;">CMD 32: RENAME</p>

<p style="margin-left:22%;">Implements the BASIC <i>XIO
32,#channel,aux1,aux2,&ldquo;H:oldname,newname&rdquo;</i>
command. Note that the file specification of this command
consists of an existing filename, a comma &ldquo;,&rdquo;,
and a new file name. This command attempts to rename the
existing file to a new name.</p>

<p style="margin-left:11%;">CMD 33: DELETE</p>

<p style="margin-left:22%;">Implements the BASIC <i>XIO
33,#channel,aux1,aux2,&ldquo;H:filespec&rdquo;</i> command
and attempts to remove (delete) the given files or patterns.
It will fail if the files are not user-readable, i.e. appear
&ldquo;locked&rdquo; in the emulator.</p>

<p style="margin-left:11%;">CMD 34: VALIDATE</p>

<p style="margin-left:22%;">An extension following DOS 3
conventions also reachable within BASIC with <i>XIO 34,</i>
this command will check whether the given filespec is
well-formed and will return an error code if not. It does
not attempt to open any file.</p>

<p style="margin-left:11%;">CMD 35: UNPROTECT</p>

<p style="margin-left:22%;">Implements the <i>XIO 35</i>
command which &ldquo;unlocks&rdquo; the given file(s) and
allows write-access into it. The host system reflects this
operation by enabling the user-writeable permission bit.</p>

<p style="margin-left:11%;">CMD 36: PROTECT</p>

<p style="margin-left:22%;">Implements the BASIC <i>XIO
36</i> command and &ldquo;locks&ldquo; the filespec by
removing the user write-permission bit.</p>

<p style="margin-left:11%;">CMD 37: POINT</p>

<p style="margin-left:22%;">Unlike command 32 to 36 above,
this expects that the given channel is already linked to an
open stream. It implements the basic <i>POINT
#ch,sector,byte</i> command for placing the file pointer
within the file. The Os. <b>CIO</b> places the sector offset
in AUX4 and AUX5 and the byte offset into AUX3. However,
conventions for file addressing are different from DOS 2.0S
and are more orthogonal. The <b>H:</b> handler appears to
have sectors of 256 bytes each, numbered linearly from 0 up
within each file. Sectors are not global within the filing
sytem but local to the file linked to the channel. This is
somewhat similar to the DOS 3 implementation of
<i>POINT.</i></p>

<p style="margin-left:11%;">CMD 38: NOTE</p>

<p style="margin-left:22%;">Similar to command 37, this
command expects an open stream on the same channel,
implementing the BASIC <i>NOTE #ch,sector,byte</i> command.
It reads the file pointer within the opened file and returns
byte and sector offsets using the same conventions as
<i>POINT.</i> Bytes are numbered consequently from 0 to 255,
and sectors are numbered from the start of the file from
zero up, each of them but possibly the last carrying 256
bytes of data. As long as programs use the values returned
by <i>NOTE</i> as opaque values and avoid to perform algebra
on them, this remains compatible to the DOS 2.0S. However,
programs expecting 125 byte sectors and absolute sectoring
are likely to fail.</p>

<p style="margin-left:11%;">CMD 40: RESOLVE</p>

<p style="margin-left:22%;">This command resolves a wild
card sequence by a real filename. It reads the wildcard from
IOCBAdr, and places the resolved filename back into the
buffer pointed to by IOCBAdr as well. To be able to resolve
non-unique wildcards, IOCBAux2 defines which of the
non-unqiue matches shall be returned. It counts from one up,
and returns the n-th found match to the specified
wildcard.</p>

<p style="margin-left:11%;">CMD 41: BINARY LOAD</p>

<p style="margin-left:22%;">Load an executable file, and
possibly initialize and run it if the file AUX2 specifies
whether the loaded file shall be initialized or run. If set
to 192, the file is initialized and run, 128 means
&ldquo;init only&rdquo;, 64 just runs, but does not
initialize the file, and 0 neither runs nor initializes the
file.</p>

<p style="margin-left:11%;">Unimplemented commands</p>

<p style="margin-left:22%;">The <b>H:</b> device does not
implement the various format commands for obvious reason. It
also doesn&rsquo;t implement some DOS 2.XL resp. DOS 3
extensions to initialize a DOS. Especially, opening the
DOS.SYS file for writing will not perform anything
special.</p>

<h2>THE E: HANDLER
<a name="THE E: HANDLER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The operating
system editor handler is responsible to collect user input
from the screen, and output data back on it. It is usually
left alone as all necessary components are emulated to let
it function as is. However, to script the editor, it is
sometimes feasible to redirect the output that would
normally go to the editor of the machine to a Unix or
Windows file, and to read input that would normally come
from the keyboard from a file as well. For that, use the
operating system patch <i>-installedevice on</i> which will
replace the Atari handler by a patch running on the host
system. Input data will be read from the standard input of
the emulator command, and output will go <b>both</b> to the
emulator front-end <b>and</b> the standard-output of the
emulator command. Only a limited number control character
transpositions will be available, though --- namely, the
following standard ANSI control characters will be
recognized and translated accordingly:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-141944.png" alt="Image grohtml-141944.png"></p>

<p style="margin-left:11%; margin-top: 1em">Cursor movement
and other advanced sequences are left alone, they are output
device dependent and require a more careful analysis that
depends on the console type used. If you need to run the
emulator in a console, consider the <b>curses</b> front-end
instead.</p>

<p style="margin-left:11%; margin-top: 1em">Another
limitation of the <b>E:</b> device patch is that it
obviously cannot emulate the full-screen editor buffer of
the Atari ROM as it has no access to the screen of the
emulator. Instead, only the line-buffering of the console is
available, i.e. the emulator will not be able to see your
input unless you press <b>RETURN.</b> This also holds for
the keyboard device, for which a patch is provided along
with this option. Specifically, if software running in the
emulator requires you to press a key, you need to terminate
this input by <b>RETURN</b> to make it accessible to the
emulator.</p>

<h2>THE R: HANDLER
<a name="THE R: HANDLER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The R: handler
is part of the emulated 850 interface box and not specific
to the emulator. A real 850 would also provide this handler.
Unlike the H: handler, the R: handler is not installed by
the emulator directly, and is not available unless it is
booted by a dedicated file. An Atari DOS distribution should
either contain a file named <b>HANDLERS.SYS</b> or an
apropriate <b>AUTORUN.SYS</b> file to bootstrap this
handler. Dos 2.5, for example, provides a setup program to
generate the apropriate file. This bootstrap code is not
specific to the emulator and works generically for the real,
as for the emulated 850 interface box. For the real 850, the
bootstrap code loads code from the interface into the Atari;
for Atari++, this code is part of the 850 emulation, but
uses otherwise the same command set as the real 850,
providing maximal compatibility.</p>

<p style="margin-left:11%; margin-top: 1em">The emulator
even emulates some of the limitations of the 850 system:
Once opened, the R: handler is in <b>block mode</b> , only
allowing you to write blocks of data asynchroniously, but
not allowing you to receive data. In block mode, 850 I/O can
be mixed freely with any other disk I/O.</p>

<p style="margin-left:11%; margin-top: 1em">With a special
XIO command, the handler must be put into <b>concurrent
mode</b> to be able to read and write data synchroniously.
In this mode, data gets sent out immediately as it is
written, and input data can be received back as soon as it
arrives, but any other device on the serial chain is
unreachable and cannot be used savely. Thus, the disk is
unavailable in concurrent mode.</p>

<p style="margin-left:11%; margin-top: 1em"><b>COMMAND
SET</b> <br>
The following set of CIO commands are made available by the
R: handler: <br>
CMD 3: OPEN</p>

<p style="margin-left:22%;">Open a channel to the R:
handler. Aux1 is either 8 for output only in block mode, 5
for input with concurrent mode support, 9 for output in
block and concurrent mode, and 13 for input/output,
including concurrent mode support. Aux2 is ignored.</p>

<p style="margin-left:11%;">CMD 5: GET RECORD</p>

<p style="margin-left:22%;">Reads characters up to an
<b>EOL</b> character, or up to the buffer end, into a
buffer. Reading is only available in concurrent mode. Read
characters can be optionally translated from ASCII into
ATASCII, see CMD 38 below.</p>

<p style="margin-left:11%;">CMD 7: GET CHARACTERS</p>

<p style="margin-left:22%;">Reads a block of characters
into a buffer. Again, only available in concurrent mode.</p>

<p style="margin-left:11%;">CMD 9: PUT RECORD</p>

<p style="margin-left:22%;">Writes characters up to an
<b>EOL</b> or up to the end of the buffer into the opened
stream. Available in block mode or in concurrent mode. In
block mode, data is buffered and transmitted as soon as
either the buffer becomes full, or an EOL is sent. In
concurrent mode, data is sent out immediately. In both
modes, characters can be optionally translated from ATASCII
into ASCII.</p>

<p style="margin-left:11%;">CMD 11: PUT CHARACTERS</p>

<p style="margin-left:22%;">Writes a block of characters
into a stream, not necessarely terminated by an <b>EOL.</b>
Otherwise identically to the above.</p>

<p style="margin-left:11%;">CMD 12: CLOSE</p>

<p style="margin-left:22%;">Releases the given stream,
possibly empties the buffer in block mode, or waits until
the write buffer is empty in concurrent mode.</p>

<p style="margin-left:11%;">CMD 13: STATUS</p>

<p style="margin-left:22%;">Requests the status of the
given stream. Additionally, memory locations $2ea to $2ed
are filled with useful information. Location $2ea contains
the error flags of the serial transfer as follows:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-141945.png" alt="Image grohtml-141945.png"></p>

<p style="margin-left:22%; margin-top: 1em">The difference
between bit 6 and bit 4 is that bit 6 gets set if the
emulated Atari could not react fast enough on interrupts,
and bit 4 gets set if the user-provided input buffer
overruns in receive mode, though the data could have been
catched successfully.</p>

<p style="margin-left:22%; margin-top: 1em">Location $2eb
contains the state of the handshake lines in block mode:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-141946.png" alt="Image grohtml-141946.png"></p>

<p style="margin-left:22%; margin-top: 1em">The history
bits mirror the state of the lines that has been returned by
the previous &ldquo;STATUS&rdquo; command.</p>

<p style="margin-left:22%; margin-top: 1em">Locations $2ec
to $2ed are unassigned in block mode.</p>

<p style="margin-left:22%; margin-top: 1em">In concurrent
mode, $2eb and $2ec contain the low- and high-byte
representing the number of characters in the input buffers,
respectively. Location $2ed contains the number of
characters in the output buffer.</p>

<p style="margin-left:11%;">CMD 32: FORCE</p>

<p style="margin-left:22%;">Flushes the output buffer in
block mode, or waits until the output buffer has been
transmitted in concurrent mode.</p>

<p style="margin-left:11%;">CMD 34: SETLINES</p>

<p style="margin-left:22%;">Only available in block mode,
not in concurrent mode. This command selects the states of
the output lines RTS and DTR. On the real 850, the state of
the data line TxD can be selected, too. The bits in Aux1 are
interpreted as follows:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-141947.png" alt="Image grohtml-141947.png"></p>

<p style="margin-left:22%; margin-top: 1em">Currently, the
emulator does not support direct state changes on TxD,
though. The value of Aux2 is ignored.</p>

<p style="margin-left:11%;">CMD 36: SETBAUD</p>

<p style="margin-left:22%;">Specifies the baud rate and
other serial transfer parameters, and handshaking. Only
available in block mode, not available in concurrent mode.
The bits in Aux1 are interpreted as follows:</p>

<p style="margin-left:22%; margin-top: 1em">If bit 7 is
set, at least two, maybe more stop bits are generated. If
the bit is clear, one stop bit, maybe more can be generated.
Bit 6 is unsed, Bits 5 and 4 specify the number of data
bits: If set to zero, eight data bits are transmitted, for
16 (bits = 0,1 resp.) seven bits are used, for 32 (bits =
1,0) six data bits are generated, and for 48 (bits = 1,1)
five data bits are sent. Bits 3 to 0 define the baud rate
according to this table:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-141948.png" alt="Image grohtml-141948.png"></p>

<p style="margin-left:22%; margin-top: 1em">Note that
values 14 and 15 generate the same rate.</p>

<p style="margin-left:22%; margin-top: 1em">The bits of
Aux2 indicate which serial lines have to be monitored if
concurrent mode is entered. If the selected serial lines are
not set, an error is generated. For the emulator, monitoring
of CTS also enables hardware handshake.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-141949.png" alt="Image grohtml-141949.png"></p>

<p style="margin-left:11%;">CMD 38: SETPARITY</p>

<p style="margin-left:22%;">This command is available in
block as well as in concurrent mode. It selects character
translations from ASCII into ATASCII and vice versa, and
selects input and output parity. The bits in Aux1 have the
following meaning:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-1419410.png" alt="Image grohtml-1419410.png"></p>

<p style="margin-left:22%; margin-top: 1em">If the
character translation is set to 0, EOL is translated to CR
(not LF!) and vice versa, and bit 7 is stripped off. If set
to 16 (bits = 0,1), additionally non-ASCII characters are
not written, resp. replaced by Aux2 on input.</p>

<p style="margin-left:22%; margin-top: 1em">If the parity
bits are set to zero, data is read or written &ldquo;as
is&rdquo;. This especially implies that parity bits <i>and
stop bits</i> of the input data are not stripped off.
Furthermore, on output only eight data bits can be
generated, unless the upper bits are set to one manually to
emulate stop bits.</p>

<p style="margin-left:22%; margin-top: 1em">If the parity
bits are set to one (bits = 0,1), odd parity is generated or
checked for. This works only for seven or less data
bits.</p>

<p style="margin-left:22%; margin-top: 1em">For the parity
bits set to two (bits = 1,0), even parity is generated or
checked for seven or less data bits.</p>

<p style="margin-left:22%; margin-top: 1em">For parity bits
set to three (both bits set, bits = 1,1), the parity bit is
stripped off on input, and always set on output (parity =
SPACE).</p>

<p style="margin-left:22%; margin-top: 1em">Aux2 of this
command specifies a &ldquo;garbadge character&rdquo; that
gets inserted for full character translation whenever a
non-ATASCII character is received.</p>

<p style="margin-left:11%;">CMD 40: STARTCONCURRENT</p>

<p style="margin-left:22%;">Enters the concurrent mode from
block mode. The only way to leave the concurrent mode again
is to close and re-open the channel. Aux1 and Aux2 are
irrelevant for this command, but IOCBAdr and IOCBLen might
provide the location and size of an optional input buffer
where incoming data is kept until it is read off. This
buffer should better be large for &ldquo;higher&rdquo; baud
rates. If no input buffer is supplied, i.e. IOCBAdr is set
to NULL, the handler will provide a short 32 byte input
buffer.</p>

<p style="margin-left:22%; margin-top: 1em">On entering
concurrent mode, the input lines specified by the
&ldquo;SETBAUD&rdquo; command are monitored <b>once.</b> If
the selected lines are not set, an error is generated. The
real 850 interface does not provide full hardware
handshaking, the emulated 850 does by monitoring CTS.</p>

<h2>THE OS ROM EMULATION
<a name="THE OS ROM EMULATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The Atari++
emulator provides its own operating system in case no Atari
ROM image is available. This makes the emulator
self-contained as you don&rsquo;t require to hold any usage
rights on the original ROMs to run it. The built-in ROM
implements a full Atari XL operating system and tries to be
compatible to the XL ROM in most aspects; however, since it
is a re-implementation, absolute ROM addresses and
implementation details may, and will, differ. The paragraphs
below give a brief overview on the ROM features, the
subsections discuss the features in more detail. <br>
Built-in FMS (DOS)</p>

<p style="margin-left:22%;">The built-in operating system
comes with its own file management system, unlike the
original Atari ROMs. This is classically, but imprecisely,
called the <b>DOS</b> (Disk Operating System). This FMS is
used in case no bootable disk is available on bootstrap.
This allows easy loading and saving of binary images without
requiring an Atari copyrighted FMS. For details, see the
<b>FMS subsection</b> below.</p>

<p style="margin-left:11%;">Parallel Port Support</p>

<p style="margin-left:22%;">has been dropped. This is
because Atari++ neither emulates any parallel port devices,
nor does the author has any usable documentation about
it.</p>

<p style="margin-left:11%;">The MathPack</p>

<p style="margin-left:22%;">is classically not considered
part of the operating system, but is emulated fully with all
documented and some undocumented entry points the author is
aware of. The emulation is complete enough to allow BASIC
and many other programs operate properly, except that the
re-implementation is usually a bit and sometimes
considerably faster. You might also consider the <b>MathPack
patch</b> option that evaluates the mathematical operations
on the host CPU and improves the speed beyond what is
achievable with the 6502 implementation.</p>

<p style="margin-left:11%;">The C: Tape handler</p>

<p style="margin-left:22%;">is replaced by a dummy. This is
because Atari++ does not emulate the tape device, and the
ROM space was required.</p>

<p style="margin-left:11%; margin-top: 1em"><b>CHARACTER
GENERATOR</b> <br>
The international character set at position 0xcc00 and up
has been slightly modified. Character position 8 (Ctrl-H) is
now the Euro-sign, character position 96 (Ctrl-.) is the
german sharp-s. The pound sign and the inverted exclamation
mark are no longer available.</p>

<p style="margin-left:11%; margin-top: 1em"><b>INTERRUPT
HANDLING</b> <br>
The Os NMI handler also checks the ANTIC Reset NMI signal
and, if detected, jumps indirectly through the vector in
location $24e. This vector points to the warmstart Os
vector. Unknown NMI sources are ignored, unlike the original
Os which handles them as VBIs. <br>
VBI Handler</p>

<p style="margin-left:22%;">The built-in Os vertical
retrace handler (VBI) does not check whether TRIG3 and its
shadow-register coincide. This avoids a couple of deadlock
situations in various games that overwrite the shadow
register. VBI handling of 1200XL keyboard features is not
present since atari++ does not emulate these keys and the
author has no precise documentation about them.</p>

<p style="margin-left:11%;">IRQ Handler</p>

<p style="margin-left:22%;">The IRQ handler is more
streamlined than the original IRQ handler; it also no longer
handles any parallel port related interrupts since they are
never generated by the emulator.</p>

<p style="margin-left:11%; margin-top: 1em"><b>KERNEL</b>
<br>
Parallel port call-ins</p>

<p style="margin-left:22%;">have been replaced by
dummies.</p>

<p style="margin-left:11%;">$e48f: BOOT850</p>

<p style="margin-left:22%;">This is a new kernel-call in
that bootstraps the 850 interface handler thru SIO. It
should be typically used by a minimal HANDLERS.SYS file that
contains nothing but a RUN-vector to this call-in.</p>

<p style="margin-left:11%;">$e45c: SETIRQVECTOR</p>

<p style="margin-left:22%;">The SetIRQVector call-in can
now also savely install IRQs as well without requiring the
caller to set the interrupt bit of the CPU.</p>

<p style="margin-left:11%;">$e492: RUNDUP</p>

<p style="margin-left:22%;">This vector launches the DUP
keyboard command processor. The DUP vector at $a,$b points
to this address by default. The built-in DUP can be replaced
by a custom DUP by changing the reset-resident vector at
$3f6.</p>

<p style="margin-left:11%;">$e498: FMSINIT</p>

<p style="margin-left:22%;">This vector initializes the
built-in FMS. The Os reset initializes the ROM-based FMS
thru this vector if no bootable disk is found.</p>


<p style="margin-left:11%; margin-top: 1em"><b>RESET/Bootstrap</b>
<br>
Tape bootstrap</p>

<p style="margin-left:22%;">Since the built-in Os does not
implement a usable tape device, tape bootstrap is no longer
supported. The CASINIT vector (0x02/0x03) is, however,
emulated properly.</p>

<p style="margin-left:11%;">Disk bootstrap</p>

<p style="margin-left:22%;">The built-in Os tries to
bootstrap the disk as usual, but does not loop forever in
case it detects that no disk is inserted in the drive. In
case an usable boot block is found, the resident FMS is not
installed and a disk-based DOS can replace it, as usual. The
resident FMS is launched if either no usable boot block is
found, no usable disk is found, or the user holds down the
START key on bootstrap. An unusable boot block is indicated
by a bootstrap address of zero, thus by a blank boot block.
Note that START is no longer an indication for tape
bootstrap since there is no tape support. In case the
built-in FMS gains control in the boot process, see below in
the <b>FMS</b> subsection for further bootstrap
activity.</p>

<p style="margin-left:11%;">850 interface bootstrap</p>

<p style="margin-left:22%;">In case the disk bootstrap
failed because no disk is inserted, the ROM also tries to
bootstrap the 850 interface box since no HANDLERS.SYS file
can be loaded then.</p>


<p style="margin-left:11%; margin-top: 1em"><b>SELFTEST</b>
<br>
The ROM space occupied by the self-test was required for the
DOS command line (the <b>DUP</b> ) and is therefore no
longer part of the Os. Instead, the following color codes
appear on the screen if the power-on tests fail: <br>
Color code RED</p>

<p style="margin-left:22%;">The RAM test failed, a faulty
RAM chip has been detected.</p>

<p style="margin-left:11%;">Color code PINK</p>

<p style="margin-left:22%;">The ROM checksum is faulty.</p>

<p style="margin-left:11%;">Color code BLUE</p>

<p style="margin-left:22%;">The bootstrap code could not
open the initial editor handler.</p>

<p style="margin-left:11%; margin-top: 1em"><b>SERIAL I/O
(SIO)</b> <br>
SIO interrupts</p>

<p style="margin-left:22%;">The serial communication is
initiated thru the Pokey XMTDONE interrupt. This makes it
easier for future extensions to relocate disk buffers under
the Os ROM.</p>

<p style="margin-left:11%;">Parallel port handling</p>

<p style="margin-left:22%;">of SIO communications has been
dropped due to lack of ROM space and documentation.</p>

<p style="margin-left:11%;">Tape device handling</p>

<p style="margin-left:22%;">is no longer provided by SIO
since Atari++ does not emulate the tape anyhow. Trying to
use the tape thru SIO will now initiate a standard serial
communication and will no longer use two-tone modulation.
Thus, tapes won&rsquo;t work as expected.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Resident
Disk handler (DISKINTERF)</b> <br>
Format command</p>

<p style="margin-left:22%;">The DISKINTERF vector handles
now the enhanced density format command of the 1050 floppy
drive correctly. Thus, it supports the 1050 command set
fully.</p>

<p style="margin-left:11%;">Parallel port I/O</p>

<p style="margin-left:22%;">thru DISKINTERF via SIO is no
longer possible since SIO does not try to interact with the
parallel port any more.</p>

<p style="margin-left:11%; margin-top: 1em"><b>CENTRAL I/O
(CIO)</b> <br>
CIO CMD_OPEN</p>

<p style="margin-left:22%;">The CIO <b>OPEN</b> command
installs now the PUT ONE BYTE vector before calling the OPEN
vector of the corresponding handler. This allows the handler
to overload this vector in order to implement
&ldquo;bursting&rdquo; more easily. Currently, the FMS makes
use of this feature to avoid the check whether it was called
from the BASIC ROM that incorrectly uses this vector.</p>

<p style="margin-left:11%;">CIO HATABS extension</p>

<p style="margin-left:22%;">thru the parallel port linked
list is not implemented since the author has no sufficient
documentation about its implementation and usage.</p>

<p style="margin-left:11%;">CIO handler bootstrap</p>

<p style="margin-left:22%;">is no longer supported due to
lack of documentation.</p>

<p style="margin-left:11%; margin-top: 1em"><b>THE C: TAPE
HANDLER</b> <br>
is only a dummy that returns error conditions on all I/O
operations. It only remained in the ROM to allow the H:
handler to patch it over.</p>

<p style="margin-left:11%; margin-top: 1em"><b>THE K:
KEYBOARD HANDLER</b> <br>
works like its equivalent in the Atari 800XL ROM except that
it does not check for Atari 1200XL function keys. Extended
editor keyboard functions are provided to the best knowledge
of the author, though. The K: handler respects now the BREAK
key correctly.</p>

<p style="margin-left:11%; margin-top: 1em"><b>THE E:
EDITOR</b> <br>
The editor device is much more decoupled from the screen
handler than in the original ROM, see also the S: handler
section below. <br>
Editor Buzzer</p>

<p style="margin-left:22%;">The buzzer is run on a cursor
position that depends on the editor margins now. It is also
rung on character insertion if characters are likely to be
moved out of the screen.</p>

<p style="margin-left:11%;">Editor Window</p>

<p style="margin-left:22%;">Unlike the original Atari
Editor device, the emulated E: handler allows arbitrary high
editor windows, not just four or 24 lines - if programmed
properly.</p>

<p style="margin-left:11%;">Editor Scrolling</p>

<p style="margin-left:22%;">on line insertion or delection
does no longer overwrite memory above MEMTOP.</p>

<p style="margin-left:11%; margin-top: 1em"><b>THE S:
SCREEN HANDLER</b> <br>
As mentioned above, the S: handler is decoupled from the E:
handler and therefore reacts in certain aspects differently
than its original counterpart. <br>
Screen GET/PUT</p>

<p style="margin-left:22%;">The S: handler no longer tries
to scroll, neither does it respect editor margins. If the
put or get commands reach the end of the screen, an
out-of-bounds error (error 141) is generated. The only
control codes the screen handler handles separately are $7d,
which clears the screen, and $9b, which implements a line
feed, though dos not scroll.</p>

<p style="margin-left:11%;">Open Command</p>

<p style="margin-left:22%;">The S: open provides more
graphic modes than the original. If 64 is added to the
graphics mode, then a text window is generated even for the
graphic modes 9, 10 and 11. Unlike in the original Os,
smooth scrolling works correctly in text windows, even in
text windows of the GTIA modes 9 to 11.</p>

<p style="margin-left:11%;">DMA/Player-Missile</p>

<p style="margin-left:22%;">The S: handler no longer
interacts with player/missile graphics and respects the
corresponding bits in the DMACTRL shadow register.</p>

<p style="margin-left:11%;">Out of memory situations</p>

<p style="margin-left:22%;">will be handled more graceful
than in the original ROM.</p>

<p style="margin-left:11%; margin-top: 1em"><b>THE P:
PRINTER HANDLER</b> <br>
The built-in ROM supports the printer to full extend, and no
functional changes should hopefully appear.</p>

<p style="margin-left:11%; margin-top: 1em"><b>MATH
PACK</b> <br>
The MathPack is not part of the operating system, but
historically part of the BASIC. As a consequence, the math
pack is does not provide a jump-in table as the operating
system, and fixed ROM-addresses must be used.</p>

<p style="margin-left:11%; margin-top: 1em">Atari++ also
provides an emulation, or rather a replacement implementing
the same routines as the original math ROM. The precision
and speed of the re-implementation should be superior to the
original ROM implementation. However, it is, in general
though, advisable to use the <b>MathPackPatch</b> which is
again a lot faster and still more precise than the
re-implementation because it uses the floating-point math of
the host machine.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTE:</b>
While the author tried its best to make the replacement
math-pack as compatible as possible to the original ROM,
some problems should be expected. BASIC and MAC/65 software
should be mostly unaffected, but since Atari never provided
a jump-in table for the math-pack, third-party software
might use routines of the math-pack that have never been
officially documented, and are not provided by the
emulation. Despite that, this math-pack replacement does
already contain a number of in-official call-ins that are
used by BASIC and other software. Nevertheless, numerical
results obtained by this implementation might differ from
the original due to round-off issues where the
re-implementation offers often better more precise
results.</p>

<p style="margin-left:11%; margin-top: 1em">The replacement
math-pack provides the following routines and data: <br>
AFP $d800</p>

<p style="margin-left:22%;">Convert the ATASCII number in
the buffer pointed to by &quot;inbuff&quot; ($f3,$f4) at
offset given by &quot;cix&quot; ($f2) into a floating point
number in &quot;fr0&quot; ($d4 to $d9). On output,
&quot;cix&quot; points to the first character that could not
be converted. The carry register is set in case no
conversion could be conformed at all. Unlike the original,
this routine operates at ten instead of nine-digits
precision and rounds properly if more than ten digits are
provided.</p>

<p style="margin-left:11%;">FASC $d8e6</p>

<p style="margin-left:22%;">Convert the floating point
number in &quot;fr0&quot; ($d4 to $d9) into ATASCII in the
output buffer at $580 and following. &quot;fr0&quot; is
destroyed on completion. The end of the string is indicated
by setting the MSB of the last character, the final string
is pointed to by &quot;inbuff&quot; ($F3,$F4) on exit.
Unlike the ROM implementation, this routine is more
streamlined and does not overwrite bytes in front of the
output buffer, the output will always start at, and not
sometimes in front of $580. If called at FASC+3, the user
can define its output buffer where he likes by placing the
address into &quot;inbuff&quot;. This is not available in
the original ROM.</p>

<p style="margin-left:11%;">IFP $d9aa</p>

<p style="margin-left:22%;">Convert the unsigned integer in
&quot;fr0&quot;(lo) and &quot;fr0+1&quot;(hi) into a
floating point representation to &quot;fr0&quot; ($d4 to
$d9). Unlike in the original ROM ,&quot;IFP+4&quot; converts
the integer in the registers X(lo) and Y(hi) into floating
point.</p>

<p style="margin-left:11%;">FPI $d9d2</p>

<p style="margin-left:22%;">Convert the floating point
number in &quot;fr0&quot; ($d4 to $d9) into a two-byte
integer representation, also in &quot;fr0&quot; and
&quot;fr0+1&quot;, rounded correctly to the nearest integer.
If the conversion is not possible, the carry bit will be
set. The original implementation had a couple of issues on
overflow and rounding that are not reproduced here.</p>

<p style="margin-left:11%;">ZFR0 $da44</p>

<p style="margin-left:22%;">Initialize the &quot;fr0&quot;
register ($d4 to $d9) with zero.</p>

<p style="margin-left:11%;">AF1 $da46</p>

<p style="margin-left:22%;">Initialize the six-byte
floating point register pointed to by the X register with
zero.</p>

<p style="margin-left:11%;">ZERORGS $da48</p>

<p style="margin-left:22%;">Clear N bytes starting at the
zero-page register given by X, where N is given in the Y
register. This inofficial call-in is used by Mac/65 and
BASIC.</p>

<p style="margin-left:11%;">LOADOUTBUFF $da51</p>

<p style="margin-left:22%;">Initialize the
&quot;inbuff&quot; zero page registers ($f3 and $f4) to
point to the floating point output buffer at $580. Used by
BASIC and MAC/65.</p>

<p style="margin-left:11%;">FADD $da66</p>

<p style="margin-left:22%;">Add the contents of the
floating point register &quot;fr1&quot; ($e0 to $e5) to the
floating point register &quot;fr0&quot; ($d4 to $d9).
&quot;fr1&quot; will be destroyed. Sets the carry in case
the representation overflows, and destroyes &quot;fr1&quot;.
Unlike the orignal, this routine employes a correct
&quot;round to nearest&quot; policy if the output cannot be
represented exactly, and it also uses denormalized numbers
if the output is very close to zero.</p>

<p style="margin-left:11%;">FSUB $da60</p>

<p style="margin-left:22%;">Subtracts the contents of the
floating point register &quot;fr1&quot; ($e0 to $e5) from
the floating point register &quot;fr0&quot; ($d4 to $d9).
&quot;fr1&quot; will be destroyed. Otherwise, works like the
floating point addition and its new round-to-nearest
mode.</p>

<p style="margin-left:11%;">FMUL $dadb</p>

<p style="margin-left:22%;">Multiplies the contents of
&quot;fr1&quot; ($e0 to $e5) with &quot;fr0&quot; ($d4 to
$d9) and places the result in &quot;fr0&quot;.
&quot;fr1&quot; will be destroyed. On overflow, the carry
flag of the processor will be set. Like addition, this
routine uses a smarter round-to-nearest policy, and unlike
the original, has all issues on detecting overflows fixed,
specifically, multiplying two very small numbers will give
zero, not an overflow. It will also handle denormalized
numbers correctly, and is noticably faster than the
original.</p>

<p style="margin-left:11%;">FDIV $db28</p>

<p style="margin-left:22%;">Divides the contents of
&quot;fr0&quot; ($d4 to $d9) by the contents of
&quot;fr1&quot; ($e0 to $e5) and places the result in
&quot;fr0&quot;, destroying &quot;fr1&quot;. On overflow or
divide by zero, the carry flag will be set. This routine
also uses a precise round-to-nearest policy. Unlike the
original routine, dividing a small number by a very large
number will not create an overflow, but - as appropriate -
zero.</p>

<p style="margin-left:11%;">SKIPBLANKS $dba1</p>

<p style="margin-left:22%;">This routine is not officially
documented but nevertheless used by Mac/65. It skips all
blank-characters in the input buffer ($f3,$f4) at offset in
&quot;cix&quot; ($f2) and adjusts &quot;cix&quot; such that
it points at the first non-blank character.</p>

<p style="margin-left:11%;">TESTDIGIT $dbaf</p>

<p style="margin-left:22%;">Another inofficial function
used by Mac/65 and BASIC. This function tests the character
at &quot;inbuff&quot; ($f3,f4) at offset &quot;cix&quot;
($f2) for a valid decimal digit and returns the numerical
value of this digit and the carry flag cleared if possible.
Otherwise, on an invalid digit, the carry flag gets set.</p>

<p style="margin-left:11%;">FR0TIMESTEN $dbeb</p>

<p style="margin-left:22%;">This is also an inofficial
vector that multiplies the mantissa of the fr0 floating
point register at address $d4 by ten, i.e. it shifts all
digits to the left. It is used by the multiplication and
division function, and the Basic++ square root function.</p>

<p style="margin-left:11%;">NORMALIZE $dc00</p>

<p style="margin-left:22%;">This method is neither
officially documented, but used nevertheless by BASIC and
Mac/65. It normalizes the floating-point number in
&quot;fr0&quot; ($d4 to $d9), eliminating leading zero-digit
pairs in the mantissa and adjusting the exponent
accordingly. It returns with the carry flag cleared on
success and with the carry set on overflow. Unlike the
original implemenation, this version leaves near-zero
numbers denormalized, and overflows at a decimal exponent of
100, not at 99 as the original.</p>

<p style="margin-left:11%;">PLYEVL $dd40</p>

<p style="margin-left:22%;">Evaluates the polynomial whose
floating point coefficients are pointed to by X(lo) and
Y(hi) at the location given by &quot;fr0&quot; ($d4 to $d9).
The number of coefficients, and hence the degree of the
polynomial plus one is passed in the accumulator on entry.
Returns the result in &quot;fr0&quot;, and destroys
&quot;fr1&quot; ($e0 to $e5), sets the carry flag on
overflow.</p>

<p style="margin-left:11%;">FLD0R $dd89</p>

<p style="margin-left:22%;">Load &quot;fr0&quot; ($d4 to
$d9) with the floating point value pointed to by X(lo) and
Y(hi).</p>

<p style="margin-left:11%;">FLD0P $dd8d</p>

<p style="margin-left:22%;">Load &quot;fr0&quot; ($d4 to
$d9) with the floating point value pointed to by
&quot;flptr&quot; ($fc,$fd).</p>

<p style="margin-left:11%;">FLD1R $dd98</p>

<p style="margin-left:22%;">Load &quot;fr1&quot; ($e0 to
$e5) with the floating point value pointed to by X(lo) and
Y(hi).</p>

<p style="margin-left:11%;">FLD1P $dd9c</p>

<p style="margin-left:22%;">Load &quot;fr1&quot; ($e0 to
$e5) with the floating point value pointed to by
&quot;flptr&quot; ($fc,$fd).</p>

<p style="margin-left:11%;">FSTOR $dda7</p>

<p style="margin-left:22%;">Store &quot;fr0&quot; ($d4 to
$d9) to the six-byte memory buffer pointed to by X(lo) and
Y(hi).</p>

<p style="margin-left:11%;">FSTOP $ddab</p>

<p style="margin-left:22%;">Store &quot;fr0&quot; ($d4 to
$d9) to the six-byte memory buffer pointed to by
&quot;flptr&quot; ($fc,$fd).</p>

<p style="margin-left:11%;">FMOVE $ddb6</p>

<p style="margin-left:22%;">Copy the contents of
&quot;fr0&quot; ($d4 t0 $d9) to &quot;fr1&quot; ($e0 to
$e5).</p>

<p style="margin-left:11%;">EXP $ddc0</p>

<p style="margin-left:22%;">Compute a the exponential
function at the location given by &quot;fr0&quot; ($d4 to
$d9), destroys the contents of &quot;fr1&quot;. Returns with
the result in &quot;fr0&quot; and the carry cleared on
success, with carry set on overflow.</p>

<p style="margin-left:11%;">EXP10 $ddcc</p>

<p style="margin-left:22%;">Computes 10 to the power of the
number given in &quot;fr0&quot; ($d4 to $d9), destroys the
contents of &quot;fr1&quot;, returns with the carry set on
overflow or the proper result in &quot;fr0&quot;. This
implementation is not only faster than the original ROM
implementation, it is also more precise - in general, nine
to ten correct digits can be expected. It also has a couple
of issues of the original implementation fixed, namely the
exponential of a very negative number yields zero, not an
overflow, and the exponential of ten to an integer power is
always integer. BASIC uses this function to compute the
exponential, via the call-in above, but also to compute the
power function (a^b). Unfortunately, due to a bug in BASIC
revisions B and C (but not in revision A), BASIC always
rounds the result <b>up</b> to the next integer if a and b
are integer, with the side effect that if the result of this
method is a tiny little bit too large, the output will be
off by one. For example, computing 4^4 results in
256.000002, which is correct to nine places, but which is
rounded by BASIC to 257. This is a bug in BASIC and not in
this implementation; the coefficients have been carefully
choosen to avoid such situations for lower exponents, i.e.
for b=1 to 3, the result will be always correct. Enforcing
correct results for higher exponents would have resulted in
a major precision loss just to work around old bugs, which
was considered inappropriate.</p>

<p style="margin-left:11%;">FFRAC $de95</p>

<p style="margin-left:22%;">This is another call-in that is
used by BASIC which is not officially documented. It
computes the rational function (x-C)/(x+C) where the value
of x is given by the contents of the &quot;fr0&quot;
register ($d4 to $d9) and C is stored as a six-byte floating
point number pointed to by X(lo) and Y(hi). On exit, the
carry flag is set on overflow, and clear on success. Then,
the result is given in the &quot;fr0&quot; register.</p>

<p style="margin-left:11%;">LOG $decd</p>

<p style="margin-left:22%;">Compute the natural logarithm
of the number given in &quot;fr0&quot; ($d4 to $d9). Returns
with the carry set on overflow, or zero or negative input,
otherwise with the result in &quot;fr0&quot;.</p>

<p style="margin-left:11%;">LOG10 $ded1</p>

<p style="margin-left:22%;">Compute the decadic logarithm
(logarithm to the base of ten) of the number given in
&quot;fr0&quot; ($d4 to $d9). Returns with the carry set on
overflow, negative or zero input, and carry cleared and the
proper result in &quot;fr0&quot; otherwise. This method can
be expected to be faster and more precise than the original
version.</p>

<p style="margin-left:11%;">ONEHALF $df6c</p>

<p style="margin-left:22%;">Not a call-in, but rather a
floating-point constant that is used by BASIC for various
purposes, most notably for the SQR function. Its value is
0.5.</p>

<p style="margin-left:11%;">ATNCOEFF $dfae</p>

<p style="margin-left:22%;">This is not a call-in, but
rather a table of eleven floating point constants
representing the coefficients of the minimax-approximation
of the arcus tangens in the interval from 0 to 1. It is used
by the BASIC implementation of the ATN function.</p>

<p style="margin-left:11%;">NEARONE $dfea</p>

<p style="margin-left:22%;">Part of the above table, but
also used by BASIC separately, this is the constant term of
the above polynomial, and also used to adjust coefficients
outside the interval 0..1 by means of the functional
equation of ATN. The value of this constant should be
exactly one in an ideal infinite-precision implementation,
but due to various round-off errors, it is 0.9999999999 in
the Atari ROMs. In the emulated ROM, its value is 1.0
precisely.</p>

<p style="margin-left:11%;">PIOVER4 $dff0</p>

<p style="margin-left:22%;">Another floating point constant
used by BASIC, here the value of Pi divided by four correct
to ten decimal places. It is used by the ATN function in the
BASIC rom.</p>

<h2>THE D: HANDLER
<a name="THE D: HANDLER"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">This handler is
provided by the now built-in FMS that is used if
disk-bootstrap was unsuccessful or aborted by the user, see
also above. The FMS in ROM space is basically a reworked and
bugfixed version of Dos 2.XL/XA of the same author that was
streamlined to fit into the low memory Os area 0xc002 to
0xcbff. It therefore provides 963 free sectors on a standard
enhanced density disk while retaining Dos 2.0S
compatibility. In specific, the VTOC layout is
identical.</p>

<p style="margin-left:11%; margin-top: 1em">It can read Dos
2.5 disks, but it is not write-compatible to Dos 2.5. This
route was choosen basically because the author had the Dos
2.XL sources available for obvious reasons, unlike the Dos
2.5 sources. The following documents the FMS command set:
<br>
CMD 3:OPEN</p>

<p style="margin-left:22%;">Opens a file. Details depend on
AUX1 and AUX2. For AUX1 = 0, the following modes are
used:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-1419411.png" alt="Image grohtml-1419411.png"></p>

<p style="margin-left:22%; margin-top: 1em">Note that mode
9 does not waste a sector, unlike the Dos 2.0S
implementation. Mode 12 is the update mode, it generates an
EOF condition in case it is attempted to extend the file
over its initial size. Mode 13 is new and automatically
extends the file over its boundary should a write past the
EOF be sent. Unlike mode 9, the file pointer is positioned
at the start of the file initially. Mode 6 also includes a
disk title should it be provided.</p>

<p style="margin-left:22%; margin-top: 1em">For AUX2 = 128,
things change dramatically. This mode provides full random
access to the raw disk without any file management
functions; thus, this mode allows &ldquo;raw&rdquo; access
to disks. File names do not matter here as long as they are
syntactically correct, and sectors are always 128 bytes
long. The disk is understood as one big sequential file
starting at sector one and extending to its last sector.
Access to sectors is provided by means of the POINT/NOTE
commands. The following open modes are available for AUX1 =
128:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-1419412.png" alt="Image grohtml-1419412.png"></p>

<p style="margin-left:11%;">CMD 5: GET RECORD</p>

<p style="margin-left:22%;">The standard CIO record reading
command. Reads bytes until the record is full or an EOL is
detected.</p>

<p style="margin-left:11%;">CMD 7: GET CHARACTERS</p>

<p style="margin-left:22%;">Reads characters into the
buffer until either the buffer is full or an EOF condition
is reached. The FMS tries to bypass CIO, i.e. it tries to
&ldquo;burst&rdquo; to speed up processing.</p>

<p style="margin-left:11%;">CMD 9: PUT RECORD</p>

<p style="margin-left:22%;">Writes bytes to the file/disk
until either the buffer becomes empty, and EOL is found in
the buffer or an EOF condition is generated.</p>

<p style="margin-left:11%;">CMD 11: PUT CHARACTERS</p>

<p style="margin-left:22%;">Writes characters to the file
until the buffer becomes empty or an EOF condition is
generated. This command also implies bursting, if
possible.</p>

<p style="margin-left:11%;">CMD 12: CLOSE</p>

<p style="margin-left:22%;">Closes the file, writes the
last buffer out and updates the directory unless the stream
is &rdquo;raw&ldquo;.</p>

<p style="margin-left:11%;">CMD 13: STATUS</p>

<p style="margin-left:22%;">This command works a little bit
different than under DOS 2.0S and DOS 2.5 where it only
checks the validity of a file specification and the
availability of a drive. Since BASIC never supplies this
information to <b>STATUS</b> , this command was actually
unuseful in BASIC and never worked as intended.</p>

<p style="margin-left:22%; margin-top: 1em">Instead, if the
channel is already open, <b>STATUS</b> returns the status of
the last CIO operation on this specific channel, which
allows now BASIC to check, for example, whether the next
<b>GET</b> command will return an EOF by testing against the
error code 3.</p>

<p style="margin-left:22%; margin-top: 1em">If the channel
is still closed, works as it did for DOS 2.0S and DOS 2.5:
It checks the given filespec for validity, tests wether the
given disk is available and readable, and whether the file
can be written to. Otherwise, appropriate error conditions
are generated. If used from BASIC, STATUS should then be
rather replaced by a <b>XIO 13</b> command which supplies a
file name.</p>

<p style="margin-left:11%;">CMD 32: RENAME</p>

<p style="margin-left:22%;">Renames files. Requires the old
filespec, then a comma, and the new target file name. This
command may cause several identically named files. Such
files can be resolved by using the <b>/1</b> through
<b>/9</b> file specification modifier defined below.
Alternatively, this command and the next four, namely
DELETE, FIND, LOCK and UNLOCK, take a non-zero <b>aux2</b>
value which then specifies which of the specific matches to
a wildcard is to be renamed, deleted, found, locked or
unlocked.</p>

<p style="margin-left:11%;">CMD 33: DELETE</p>

<p style="margin-left:22%;">Delete one or several files on
the disk.</p>

<p style="margin-left:11%;">CMD 34: FIND</p>

<p style="margin-left:22%;">Resolves a wild card filespec
and returns a full file name in the input buffer. This
command is used by the command line interpreter
(&ldquo;DUP&rdquo;) to resolve wild-cards.</p>

<p style="margin-left:11%;">CMD 35: LOCK</p>

<p style="margin-left:22%;">Prevents a file or several
files from getting overwritten by setting their
write-protecting bits.</p>

<p style="margin-left:11%;">CMD 36: UNLOCK</p>

<p style="margin-left:22%;">Removes the write-protection
lock on a file or several files.</p>

<p style="margin-left:11%;">CMD 37: POINT</p>

<p style="margin-left:22%;">Places the file pointer at a
given file/sector position. Unfortunately, the FMS
doesn&rsquo;t provide simple sequential accessing of files,
but rather expects an absolute sector/byte offset in
AUX3,AUX4 (sector) and AUX5 (byte), similar to Dos 2.0S. If
an invalid write position is specified here, then the disk
might get corrupted. Only file pointers obtained by a
previous NOTE onto the same file should be passed in as
arguments here.</p>

<p style="margin-left:22%; margin-top: 1em">Unlike under
DOS 2.0S and DOS 2.5, <b>POINT</b> also works for files
opened in <i>write-only</i> mode, i.e. mode 8, and can there
be used to re-position the file pointer to some place in
front of the EOF, overwriting data that has already been
written. Similarly, <b>POINT</b> is very helpful to append
to files in the update/append mode 13 when the former EOF
position has been recorded by a <b>NOTE</b> , which then
works much faster than having the file opened in
<i>append</i> mode. The latter has to find the EOF manually,
the former will place the file pointer directly at the
EOF.</p>

<p style="margin-left:22%; margin-top: 1em">The
<b>POINT</b> command is also used for absolute positioning
within the disk if the corresponding stream is opened for
raw mode, i.e. with AUX2 = 128.</p>

<p style="margin-left:11%;">CMD 38: NOTE</p>

<p style="margin-left:22%;">Returns the current file
pointer as sector/byte offset to be used for a future POINT
command. AUX3/4 contain the low/high-byte of the sector,
AUX5 the sector offset.</p>

<p style="margin-left:11%;">CMD 39: INIT</p>

<p style="margin-left:22%;">Clears and initializes the
disk, erasing all files, but not formatting the disk. This
is a <b>quick format</b> for disks that have been formatted
already. Optionally, a disk title can be given behind the
device specification. This title will then appear in reverse
video on each directory listing.</p>

<p style="margin-left:11%;">CMD 40: FIND</p>

<p style="margin-left:22%;">Similar to CMD 34 to maintain
Dos 2.XL compatibility.</p>

<p style="margin-left:11%;">CMD 41: BINARY LOAD</p>

<p style="margin-left:22%;">Loads a binary file from disk,
possibly initializing and running the binary. AUX2 specifies
whether the loaded file shall be initialized or run. If set
to 192, the file is initialized and run, 128 means
&ldquo;init only&rdquo;, 64 just runs, but does not
initialize the file, and 0 neither runs nor initializes the
file. Note that Atari specified CMD 41 (and not CMD 40) for
the binary load command.</p>

<p style="margin-left:11%;">CMD 42: FORMAT</p>

<p style="margin-left:22%;">Formats a disk in various
sizes. If AUX1 is set to 33, then the disk is formatted in
single density to 707 sectors. For AUX1 set to 34, then an
enhanced density format is initiated, resulting in a 963
sector disk. All other values are reserved. This command
also accepts a disk title.</p>

<p style="margin-left:11%;">CMD 43: FORMAT ENHANCED</p>

<p style="margin-left:22%;">Initiates a standard enhanced
density format, independent of AUX1 and AUX2. This also
accepts a disk name, similar to the above.</p>

<p style="margin-left:11%;">CMD 254: FORMAT ENHANCED</p>

<p style="margin-left:22%;">Identical to CMD 43.</p>

<p style="margin-left:11%; margin-top: 1em"><b>FMS FILE
SPECS</b> <br>
The built-in FMS defines the following rules for filenames;
these rules are very close to those formulated by Dos
2.0S.</p>

<p style="margin-left:11%; margin-top: 1em">The first
character must be an uppercase letter, all remaining
characters must be uppercase letters or digits. A file name
consists of at most eight characters, and an optional three
character extender behind a dot (&ldquo;.&rdquo;). Three
wild card-characters are understood: The question mark
&ldquo;?&rdquo; that matches one single arbitrary character,
the asterisk &ldquo;*&rdquo; that matches a sequence of
arbitrary characters except the dot, and the dash
&ldquo;-&rdquo; that is equivalent to the wild-card sequence
&ldquo;*.*&rdquo; and thus matches any file.</p>

<p style="margin-left:11%; margin-top: 1em">Additionally,
the FMS supports access mode modifiers that can be appended
to a file name to change the behaivour of the command. These
modifiers are appended behind a slash, &ldquo;/&rdquo;, e.g.
&ldquo;D:FILE/A&rdquo;. The following modifiers are
understood:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>/A</p></td>
<td width="2%"></td>
<td width="78%">


<p>Open a file for append mode instead of write mode, i.e.
change mode 8 to mode 9. Also changes the plain directory
mode to the restricted directory mode that suppresses the
disk name, and modifies mode 12 to mode 13. All other
combinations are invalid. This modifier is useful in the FMS
command line in combination with the COPY command to append
one file to another.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>/D</p></td>
<td width="2%"></td>
<td width="78%">


<p>Changes the open mode from reading to directory reading,
i.e. changes mode 4 to mode 6. This is, for example, useful
in the FMS command line to print the directory by means of
<b>COPY D:-/D,P:</b></p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>/O</p></td>
<td width="2%"></td>
<td width="78%">


<p>Does not modify the open mode, but rather disables
verify writes and uses the faster write without verify disk
command. This makes writes faster at the price of possibly
hiding write errors on bad disks.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>/V</p></td>
<td width="2%"></td>
<td width="78%">


<p>Similar to the above, though it enables verify
writes.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>/N</p></td>
<td width="2%"></td>
<td width="78%">


<p>Only used together with the BINARY LOAD command to
disable launching the program after having loaded it.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>/1../9</p></td>
<td width="2%"></td>
<td width="78%">


<p>If several identically named files exist, access the
n-th file of them. This access modifier allows to specify
one of several identically named files as they could have
been created by the Rename command.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Note that the
file spec &ldquo;DOS.SYS&rdquo; is <b>not at all special</b>
for the FMS, unlike DOS 2.0S; it will refer to a standard
regular file. The FMS will never ever try to write itself to
disk. Thus, even the FMS can write the disk structure of Dos
2.XL fine on disk initialization, these disks will not be
bootable without the ROM FMS.</p>

<p style="margin-left:11%; margin-top: 1em"><b>FMS ERROR
CODES</b> <br>
The FMS generates the following error codes; Not listed here
are generic SIO errors that are generated by the Os kernel,
not by the FMS: <br>
Error 160, IllegalUnit</p>

<p style="margin-left:22%;">The requested disk unit is not
available.</p>

<p style="margin-left:11%;">Error 161, TooManyFiles</p>

<p style="margin-left:22%;">Too many files are open at
once, the FMS run out of buffers.</p>

<p style="margin-left:11%;">Error 162, DiskFull</p>

<p style="margin-left:22%;">No more free store on the
disk.</p>

<p style="margin-left:11%;">Error 164, FileLinkBroken</p>

<p style="margin-left:22%;">Fms structure found damaged,
possibly because of an invalid POINT.</p>

<p style="margin-left:11%;">Error 165, FileNameInvalid</p>

<p style="margin-left:22%;">The file name is invalid.</p>

<p style="margin-left:11%;">Error 166, InvalidPoint</p>

<p style="margin-left:22%;">An argument to POINT was out of
range.</p>

<p style="margin-left:11%;">Error 167, FileProtected</p>

<p style="margin-left:22%;">A write operation to a locked
file was attempted.</p>

<p style="margin-left:11%;">Error 169, DirectoryFull</p>

<p style="margin-left:22%;">Could not create a file since
the directory was filled.</p>

<p style="margin-left:11%;">Error 170, FileNotFound</p>

<p style="margin-left:22%;">The specified filespec does not
exist.</p>

<p style="margin-left:11%;">Error 175, NoBinaryFile</p>

<p style="margin-left:22%;">The specified file is not a
binary load file.</p>

<p style="margin-left:11%;">Error 176, BadLinkage</p>

<p style="margin-left:22%;">Found a bad sector link to
sector #0, the disk structure is damaged.</p>

<p style="margin-left:11%;">Error 177, InvalidMode</p>

<p style="margin-left:22%;">The specified open mode is
invalid.</p>

<p style="margin-left:11%;">Error 178, NotADosDisk</p>

<p style="margin-left:22%;">The structure of the inserted
disk is not compatible to Dos 2.++.</p>

<p style="margin-left:11%; margin-top: 1em"><b>THE COMMAND
LINE PROCESSOR (DUP)</b> <br>
The built-in FMS also provides a disk utility package (a
&ldquo;DUP&rdquo;). It is activated from BASIC via the
<b>DOS</b> command, or is run automatically if no cart is
found inserted.</p>

<p style="margin-left:11%; margin-top: 1em">The command
line accepts commands similar to a Linux shell, except that
its commands are much more restrictive. If the command
entered is just a device specification, i.e. a one- or
two-letter string terminated by a colon, then the active
device is changed. Otherwise, the command line tries to
locate the command as file on disk, as a binary, and then
runs it. It does <b>NOT</b> append a file extender, unlike
OS/A+ which would always append &ldquo;.COM&rdquo;. The file
name is loaded and executed exactly as entered.</p>

<p style="margin-left:11%; margin-top: 1em">The full
command line including the command and its arguments is
placed in a 128 byte buffer at $580 where the executed
binary may find it, and may parse it itself if required. The
command line does not provide functions to parse this
buffer.</p>

<p style="margin-left:11%; margin-top: 1em"><b>NOTE</b>
This is not the way how Dos OS/A+ executes external
commands. There was unfortunately not enough ROM space
available to implement command line parsing service
functions as OS/A+.</p>

<p style="margin-left:11%; margin-top: 1em">If the command
starts with a double quote, or is not found on disk, then
the command line processor tries to locate this as an
internal command. The following internal commands are
available: Optional arguments are here denoted in square
brackets, these are not part of the command syntax.
<b>filespec</b> is a file specification, optionally
containing wildcards, and optionally containing a device
specification separated from the file name by a colon. If no
device name is given, the curently active device in front of
the command is used. <br>
DIR [filespec]</p>

<p style="margin-left:22%;">Lists the disk directory. If a
filespec is given, only the files matching the filespec will
be listed. <b>DIR</b> is not able to list the directory to
some other device. For that, use the <b>COPY</b> command and
a source filespec with the &ldquo;/D&rdquo; access
modifier.</p>

<p style="margin-left:11%;">DELETE filespec</p>

<p style="margin-left:22%;">Deletes the file or files that
match the filespec. Note that this command performs its work
immediately and without asking further question.</p>

<p style="margin-left:11%;">RENAME filespec,newname</p>

<p style="margin-left:22%;">Renames a file or several files
to a target filename on the same device. If more than one
file matches the wildcard, all of them are renamed to the
same target name. You can pick between various identically
named files by means of the /1 to /9 modifiers, allowing you
to rename some of them back.</p>

<p style="margin-left:11%;">LOCK filespec</p>

<p style="margin-left:22%;">Marks the file or files as
write-protected. Any kind of write operation, or deletion of
the file is then prohibited.</p>

<p style="margin-left:11%;">UNLOCK filespec</p>

<p style="margin-left:22%;">Removes the write protection
again, the opposite of the above.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>CAR</p></td>
<td width="7%"></td>
<td width="78%">


<p>Runs the cartridge should there be one inserted. If no
cart is available, and neither any reset resident program is
found, the command processor will be entered again.</p></td></tr>
</table>

<p style="margin-left:11%;">FORMAT [title]</p>

<p style="margin-left:22%;">Formats the specified disk to
enhanced density, erasing all its contents. An optional disk
name can be specified here that will be printed in inverse
video when listing the directory contents.</p>

<p style="margin-left:11%;">CLEAR [title]</p>

<p style="margin-left:22%;">Similar to the above, this
command clears the entire disk contents and installs an
optional disk name. However, the <b>CLEAR</b> command only
re-initializes an already formatted disk. By that,
<b>CLEAR</b> is much faster than <b>FORMAT</b> and intended
to be a quick-format.</p>

<p style="margin-left:11%;">RUN [hexaddress]</p>

<p style="margin-left:22%;">Runs a machine code program at
the specified address. If no address has been given, the
previously loaded command will be run, or run again.</p>

<p style="margin-left:11%;">SAVE
filespec,from,to,[[,init],run]</p>

<p style="margin-left:22%;">Saves a binary file to disk,
starting at the given hex address, up to the given address.
An optional init and run address can be given here as well.
Note that you can always append to a file, and thus extend a
binary load file, by using the &ldquo;/A&rdquo; access
modifier behind the file name.</p>

<p style="margin-left:11%;">LOAD filespec</p>

<p style="margin-left:22%;">Loads a file from disk, but
does not start it. You can run this file later by means of
the RUN command without additional arguments.</p>

<p style="margin-left:11%;">COPY filespec,target</p>

<p style="margin-left:22%;">Copies one or several files
from one disk to the same or another disk. <b>COPY</b> will
first read the file from the source, and will then wait for
you to swap disks. If the source and the target disk are
identically, just press RETURN, otherwise swap disks first.
<b>COPY</b> will then write the target file, and might ask
you again to insert the source disk if the file is too large
to be read in one go, or if more than one file is to be
copied.</p>

<p style="margin-left:22%; margin-top: 1em"><b>COPY</b>
tries to avoid using user RAM contents whenever possible.
Application memory that is reserved correctly by setting the
Os vector APPMEMHI will be preserved, and BASIC source code
will be spared. However, not all applications adjust
APPMEMHI correctly, Mac/65 is such an example.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p>NEW</p></td>
<td width="7%"></td>
<td width="78%">


<p>will erase user memory and will make this memory
available for the <b>COPY</b> command, i.e. you will require
to swap disks less often. The <b>NEW</b> command is also
necessary to inform some cartridges or application programs
that its memory has been overwritten after performing a copy
operation. This is necessary if the corresponding program
does not set APPMEMHI correctly.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>FMS HINTS
AND TWEAKS</b> <br>
Sometimes an external command has the same name as an
internal one. In this case, the external command is prefered
to the internal one and is loaded, bypassing the internal
one. If this is undesired, place a double quote in front of
the command. This will avoid the external command
lookup.</p>

<p style="margin-left:11%; margin-top: 1em">You might have
noted that the DIR command is not able to list the directory
to anything but to the screen. However, the COPY command can
perform a similar operation by using the /D access
specifier:</p>

<p style="margin-left:11%; margin-top: 1em"><b>COPY
-/D,P:</b></p>

<p style="margin-left:11%; margin-top: 1em">will print out
the contents of the directory by copying the contents of the
directory to the printer device, though invalidating RAM
contents due to the additional buffering COPY performs.</p>

<p style="margin-left:11%; margin-top: 1em">The LOAD
command can be emulated by using the no-run specifier when
you just want to load, but not to run an external command.
Thus, <b>LOAD foobar</b> and <b>foobar/N</b> are
equivalent.</p>

<p style="margin-left:11%; margin-top: 1em"><b>FMS
BOOTSTRAP PROCESS</b> <br>
If the FMS is initiated by the built-in Os, and a disk is
found active and usable, the following additional bootstrap
steps take place: <br>
FMS Configuration</p>

<p style="margin-left:22%;">The FMS tries to load and
execute the binary load file <b>D:CONFIG.SYS.</b> This file
should modify the FMS settings by writing into its
configuration area. The FMS will then re-allocate buffers
according to its new settings. Note that this is the
<b>only</b> way how to modify the FMS parameters since it is
ROM based.</p>

<p style="margin-left:11%;">Handler bootstrap</p>

<p style="margin-left:22%;">Next, the FMS tries to load and
execute the binary file <b>D:HANDLERS.SYS.</b> This file
should contain the bootstrap code for any additional
boot-time handlers that must be linked into the system. For
example, this file could load and run the 850 interface box
firmware (easiest by simply calling the Os vector BOOT850,
$e48f).</p>

<p style="margin-left:11%;">Command execution</p>

<p style="margin-left:22%;">Last, the FMS runs the
traditional <b>D:AUTORUN.SYS</b> file. This is a user
defined binary load file that could contain about anything
the user may consider.</p>

<p style="margin-left:11%; margin-top: 1em"><b>OS
EQUATES</b> <br>
In most cases, the built-in Os uses the same memory
locations as the Atari 800XL ROM, though some extensions
have been made. Note that memory cells reserved within the
XL operating system for parallel port and tape usage are
likely to be no longer in use. However, these should remain
reserved for future versions of the Atari++ operating
system. <br>
$15 FMSTMP</p>

<p style="margin-left:22%;">Used by the FMS for various
issues.</p>

<p style="margin-left:11%;">$16 DIRENTRYOFFSET</p>

<p style="margin-left:22%;">Used by the FMS to point into
the directory buffer for the currently processed file.</p>

<p style="margin-left:11%;">$1a FILECOUNTER</p>

<p style="margin-left:22%;">In case a wildcard matches
several files and the user specified a /1 to /9 access
modifier to select one of these matches, this location
records the user selection. This location stays at $ff if
the FMS shall operate on all matches.</p>

<p style="margin-left:11%;">$1b FREEDIRCODE</p>

<p style="margin-left:22%;">Keeps the file number times
four of the first free directory entry a new file could
populate.</p>

<p style="margin-left:11%;">$43 FMSPTR</p>

<p style="margin-left:22%;">Temporary pointer variables for
miscellaneous uses in the FMS. This pointer typically points
to the directory entry of the currently processed file.</p>

<p style="margin-left:11%;">$45 DISKBUFFER</p>

<p style="margin-left:22%;">Points within the FMS to the
VTOC buffer for the currently processed disk drive.</p>

<p style="margin-left:11%;">$47 FILEBUFFER</p>

<p style="margin-left:22%;">Points within the FMS to the
file input/output buffer for the currently processed
file.</p>

<p style="margin-left:11%;">$24e VECNMI</p>

<p style="margin-left:22%;">The Os jumps thru this vector
in case it detects an interrupt on ANTIC&rsquo;s NMI-input
pin. This pin is routed to the RESET key on the 400 and 800
machines, and is open on the XL and later machines.</p>

<p style="margin-left:11%;">$2b8 OVERRUNFLAG</p>

<p style="margin-left:22%;">This flag is set by the E:
handler in case the line is nearly full and the buzzer
should be run.</p>

<p style="margin-left:11%;">$318 SCREENSTACK</p>

<p style="margin-left:22%;">This byte is traditionally used
by SIO, and so it is by the built-in Os. It is, however,
also used by the S: and E: handler to keep the stack pointer
to make error handling easier.</p>

<p style="margin-left:11%;">$3f5 FMSBOOTFLAG</p>

<p style="margin-left:22%;">Specifies the FMS bootstrap
modes and various other related issues as listed in the
following table:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-1419413.png" alt="Image grohtml-1419413.png"></p>

<p style="margin-left:11%;">$3f6,$3f7 DUPVECTOR</p>

<p style="margin-left:22%;">DupVector (hi) This address is
jumped at instead of the cart run vector during a warmstart
if bit 6 of the FmsBootFlag is set. A program that jumps
thru DOSVECTOR ($a,$b) will set bit 6 of the FMSBOOTFLAG,
then cause a reset which in turn will run the command
processor thru this vector.</p>

<p style="margin-left:11%; margin-top: 1em">The next
addresses are only used if the FMS is initialized. They can
be modified from the CONFIG.SYS file to change the FMS
parameters when booting. <br>
$70a FMSDRIVEMASK</p>

<p style="margin-left:22%;">Contains a bitmask that defines
which drives should be addressable. A one-bit enables the
corresponding disk unit, a zero disables it. Bit #0
enables/disables drive 1, bit #1 controls drive 2 and so on.
The default value is 3, meaning a two-disk system is
supported. Each supported drive requires 128 bytes
additional storage.</p>

<p style="margin-left:11%;">$709 FMSBUFFERS</p>

<p style="margin-left:22%;">Number of file buffers the FMS
shall allocate. This controls how many files can be opened
at once. The default value is five, allowing to open at most
five files at once. Each file buffer requires 128 bytes of
storage.</p>

<p style="margin-left:11%;">$779 WRITECMD</p>

<p style="margin-left:22%;">The SIO command the FMS shall
use for writing sectors. This can be either $50
(&quot;P&quot;) for writing without or $57 (&quot;W&quot;)
for writing with verify. It is however suggested to use the
file name extenders &quot;/V&quot; and &quot;/O&quot; to
switch between verify on and off instead.</p>

<p style="margin-left:11%;">$70C,$70D DISKBUFFERBASE</p>

<p style="margin-left:22%;">Points to the first disk buffer
used by the FMS. The &quot;CONFIG.SYS&quot; file may change
this base address to point elsewhere, in which case disk
buffers will be allocated from this memory address on. If in
addition bit 4 of <b>FMSBOOTFLAG</b> is set, the FMS init
routine will neither try to increase MEMLO to point behind
the FMS buffers, but will keep it at the end of its state
flags.</p>

<p style="margin-left:11%;">$712,$713 FILEBUFFERBASE</p>

<p style="margin-left:22%;">This pair points to the first
file data buffer within the disk buffers. It cannot be
adjusted, but is always allocated by the FMS.</p>

<p style="margin-left:11%;">$700 to $7ff FMS STATE
FLAGS</p>

<p style="margin-left:22%;">Addresses $700-$7ff except
those above contain FMS state variables that remain
undocumented.</p>

<p style="margin-left:11%;">$800 FMS BUFFERS</p>

<p style="margin-left:22%;">FMS buffers for drives and file
buffers are allocated from $800 up. In the default
configuration, they extend up to $a7f, leaving RAM from $a80
and up to the user. Thus, the memory footprint of the
built-in FMS is much better than for DOS 2.0S. FMS buffers
may be relocated by adjusting <b>DISKBUFFERBASE</b>
accordingly by a suitable CONFIG.SYS file.</p>

<h2>THE BASIC EMULATION
<a name="THE BASIC EMULATION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Atari++
includes an emulated Basic ROM in case an original Atari
Basic ROM image is not available. The Basic dialect emulated
here closely reessembles the Atari Basic dialect and is to a
major degree compatible to it.</p>

<p style="margin-left:11%; margin-top: 1em">Basic++ is,
however, quite a bit faster due smarter stack and branch
handling, it is heavily bug-fixed, and slighly extended:
<br>
DIR [filenspec]</p>

<p style="margin-left:22%;">This statement lists the
directory of the given drive, looking for the files that
match the file specification in its argument. For
example,</p>

<p style="margin-left:22%; margin-top: 1em">DIR
&quot;D2:*.*&quot;</p>

<p style="margin-left:22%; margin-top: 1em">will list all
files on the second disk drive. If no filename is given,
<b>DIR</b> will list all files on the first disk. The
<b>DIR</b> command is compatible both in its syntax and its
internal encoding to the same TurboBasic command.</p>

<p style="margin-left:11%;">LIST
[filespec,][firstline[,[lastline]]</p>

<p style="margin-left:22%;">A second notable extension is
that the &ldquo;lastline&rdquo; argument of the list
statement can be dropped while keeping the comma upfront.
This instructs <b>LIST</b> to start listing at the line
given by the first argument, but continue up to the end of
the program. This extension is identical to the extension of
<b>LIST</b> in TurboBasic. For example,</p>

<p style="margin-left:22%; margin-top: 1em">LIST 1000,</p>

<p style="margin-left:22%; margin-top: 1em">will list all
lines starting from line 1000 up to the last line.</p>

<p style="margin-left:22%; margin-top: 1em">The remaining
extensions are minor and consist mostly of bug-fixes, speed
improvements and improvements of the numerical accuracy of
the floating point model. They are described in more detail
in the Basic++ manual.</p>

<h2>THE BUILT-IN MONITOR
<a name="THE BUILT-IN MONITOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Atari++ comes
with a build-in mini-monitor that can be helpful for
debugging programs, or for finding bugs in the emulator. The
following section describes briefly the front-end and the
commands of this monitor, assuming that the emulator has
been compiled with <i>curses</i> support. Otherwise, the
front-end is less user-friendly (or even more user
un-friendly than it used to be before, but that is another
topic).</p>

<p style="margin-left:11%; margin-top: 1em"><b>ENTERING THE
MONITOR</b> <br>
The monitor is entered either by pressing <b>F12</b> while
the emulation is active, by pressing <b>^C</b> in the shell
that launched Atari++, or if the CPU core emulator crashes.
The crash could be either due to an instruction that is not
implemented, an instruction that would otherwise stop the
CPU completely or an unstable instruction whose function
depends on some floating bus signals that are hard or not at
all emulatable. Other than that, Atari++ emulates all known
stable &ldquo;extra opcodesrq some lesser quality programs
tend to use.</p>

<p style="margin-left:11%; margin-top: 1em">Another way of
entering the monitor is due to hitting a break point, or by
finishing a single-stepped instruction.</p>

<p style="margin-left:11%; margin-top: 1em"><b>MONITOR
COMMANDS</b> <br>
The monitor is entirely command line driven. Commands are
four characters long, non-case sensitive, with a possible
abbreviation of one character. Commands furthermore have an
optional extension given by a dot <b>(.)</b> and a single
additional character. This extender typically modifies the
command somewhat, or sets some parameter for the command, as
for example the output format. The extender for each command
is remembered by the command itself up to the next time the
very same command is used. Hence, you won&rsquo;t need to
type the same extender every time. Using the question mark
&ldquo;?&rdquo; as extender lists the available extenders
for the command.</p>

<p style="margin-left:11%; margin-top: 1em">Most commands
also remember the last address they operated on. If typed
without arguments, they silently re-use the last address
used. This is handy for disassembling long routines since
you just have to re-type the disassembly command to continue
the listing.</p>

<p style="margin-left:11%; margin-top: 1em"><b>ALGEBRAIC
EXPRESSIONS</b> <br>
The monitor is capable of evaluating simple algebraic
expressions in C syntax containing the basic operators
<b>+,-,*,/,</b> the binary operators <b>&amp;,|,^,~</b> the
logical operators <b>||,&amp;&amp;,!</b> , the comparisons
<b>&lt;,&lt;=,&gt;=,==,!=</b> and the shifts
<b>&lt;&lt;,&gt;&gt;.</b> The precedence of the operators
follows mainly the C syntax except that priority of the
shifts has been &ldquo;fixed&rdquo; to follow more closely
the (or at least my) intuition, brackets are supported with
their obvious meaning. Furthermore, the contents of the
registers are available as the algebraic expressions
<b>A,X,Y,P,S,PC. Otherwise, numerical constants are
understood in hex</b> (sedecimal) notation.</p>

<p style="margin-left:11%; margin-top: 1em">If a ca65 debug
file is loaded (see <b>ENVI.S</b> below), then labels or
equates can also be used in expressions; they are then
substituted by the value they have been assigned to in the
debug file.</p>

<p style="margin-left:11%; margin-top: 1em">A nice gymmick
are the indirection operators <b>[],[].b,[].w</b> with the
first two being equivalent. They evaluate their contents as
an address, and then return the contents of this (emulator)
address as their value. The first two are byte versions
reading a single byte, the latter is a word version that
reads two bytes in little-endian notation to form a sixteen
bit integer.</p>

<p style="margin-left:11%; margin-top: 1em"><b>COMMAND
DESCRIPTION</b> <br>
The following commands are available in the monitor:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p>HELP=?</p></td>
<td width="2%"></td>
<td width="58%">


<p>This command prints a command summary.</p></td>
<td width="20%">
</td></tr>
</table>

<p style="margin-left:11%;">DUMP=D [expr]; extenders:
A,S,V</p>

<p style="margin-left:22%;">Dumps the memory contents at
the address given by the argument or continuing the last
dump. The <b>A</b> extender switches to mixed hex-ATASCII
output, emulating inverse video as much as possible thru
curses, the <b>S</b> extender uses hex-ANTIC screen code
dumps. The <b>V</b> extender doesn&rsquo;t dump anything at
all but rather sets the number of lines to dump in one
go.</p>

<p style="margin-left:11%;">EDIT=E [expr]; extenders:
X,D,A,S,I</p>

<p style="margin-left:22%;">Edit memory starting at the
given address either in hex, decimal, ATASCII or Antic
Screen codes, respectively. For hex and decimal input,
memory contents are lines separated by blanks, and the input
is aborted by an empty line, i.e. by just pressing
<b>RETURN.</b> For ATASCII and screen code editing, the text
given as input is placed directly in the memory of the
Atari, possibly first converting to the target format. The
<b>I</b> extender doesn&rsquo;t edit any memory but toggles
the seventh bit of the ATASCII resp. screen code entries on
or off.</p>

<p style="margin-left:11%;">FILL=L addr size; extenders:
X,D,A,S,I</p>

<p style="margin-left:22%;">Fill the given memory range,
given by base address and size with a byte pattern. You will
be prompted for the fill pattern separately in a second
stange: With the <b>X</b> extender, the byte pattern is
given as a space-separated list of hexadecimal (sedecimal)
byte values, with the <b>D</b> extender, this pattern is
given in decimal notation instead. Using the <b>A</b>
extender allows to enter the bytes as ATASCII codes, and the
<b>S</b> extender, last but not least, encodes the pattern
in the ANTIC screen codes.</p>

<p style="margin-left:22%; margin-top: 1em">The <b>I</b>
extender toggles the seventh bit of the entered ATASCII or
screen code pattern on or off. Its setting is ignored for
hex or decimal input.</p>

<p style="margin-left:11%;">MOVE=M from to size; extenders:
S,C,A</p>

<p style="margin-left:22%;">Move a memory block of the
given size from the start location to the target location.
Source and target may overlap, the move command will be
smart enough to copy memory blocks correctly in all
circumstances. The <b>S</b> extender will perform a simple
memory copy operation within the current address space, no
matter which one has been selected by the <i>ENVI</i>
command (see below). The <b>C</b> extender, however, will
move bytes from the selected address space into the address
space as seen from the 6502. This allows you to copy data
from the ANTIC space to the CPU space. The <b>A</b> extender
works in the reverse direction by always writing into the
ANTIC space.</p>

<p style="margin-left:11%;">FIND=F [expr]; extenders:
X,D,A,S,I,V</p>

<p style="margin-left:22%;">Scans the memory starting at
the given location for a byte pattern, possibly filtering
the pattern thru a mask. You are first prompted to enter the
byte string to look for, and then for a possible mask, that
must be either left blank or as long as the pattern entered
first. If left blank, the byte string in memory must match
the entered string precisely for a match. Otherwise, only
the <b>one-bits</b> in the mask are significant and all zero
bits in the mask are not compared against the search
pattern. This allows, for example, scanning for a text in
non-case-sensitive mode: Just set all pattern bytes to
&ldquo;5F&rdquo; for ignoring case and inverse video
bits.</p>

<p style="margin-left:22%; margin-top: 1em">The extenders
work similar to the extenders of the <b>EDIT</b> or
<b>FILL</b> commands: <b>X</b> expects hexadecimal input,
<b>D</b> requests decimal input, <b>A</b> allows ATASCII and
<b>S</b> screen code patterns. The pattern mask, however, is
always given in hexadecimal notation. As always, the
<b>I</b> extender toggles the seventh bit on or off for the
<b>A</b> and <b>S</b> extenders. Last but not least, the
<b>V</b> extender defines the maximal number of matches that
will be printed before the search is aborted.</p>

<p style="margin-left:11%;">EVAL== expr; takes no
extenders</p>

<p style="margin-left:22%;">Evaluates its argument and
prints the result on the screen.</p>

<p style="margin-left:11%;">SKTB=K [expr];</p>

<p style="margin-left:22%;">Prints a stack traceback,
optionally starting at the given stack address. For this
option, the monitor will find the locations from which the
current routine has been called. The locations of the JSR
instructions are printed on the screen.</p>

<p style="margin-left:11%;">BRKP=B [expr]; extenders:
S,C,D,E,A,L,V,W</p>

<p style="margin-left:22%;">Controls breakpoints. Once a
breakpoint is hit, and the breakpoint is enabled, the
monitor is re-entered. Breakpoints can be set in either RAM
or ROM. They do not alter the memory at all but are rather
emulated directly in the CPU core. Hence, they cannot
interact with software reading or interpreting the code.</p>

<p style="margin-left:22%; margin-top: 1em">BRKP.S installs
and activates a breakpoint at the address given by its
argument. BRKP.C removes it again. The <b>D</b> and <b>E</b>
extenders disable, resp. enable breakpoints that have been
set before. A disabled breakpoint is temporarely turned off,
but remembered, and can be turned on later on.</p>

<p style="margin-left:22%; margin-top: 1em">The <b>V</b>
and <b>W</b> extenders install watch points. Unlike regular
break points, the trapping condition is not execution of an
instruction at a specific location, but the <i>access</i> of
a specific memory address.</p>

<p style="margin-left:22%; margin-top: 1em">BRKP.W installs
a watch point, i.e. the monitor is entered as soon as a
program tries to write to the target address. Reading does
not trigger it. Watch points can be disabled and removed as
all other break points.</p>

<p style="margin-left:22%; margin-top: 1em">BRKP.V installs
a read/write watch point that unlike the above, also reacts
on read accesses to its target address.</p>

<p style="margin-left:22%; margin-top: 1em">The <b>A</b>
extender removes all breakpoints at once and the <b>L</b>
extender lists all breakpoints and their status, i.e. wether
they are disabled or enabled.</p>

<p style="margin-left:11%;">DLST=A [expr]; extenders:
L,S,V</p>

<p style="margin-left:22%;">displays the antic <i>Display
List</i> and the ANTIC status. The <b>L</b> extender prints
a disassembly of the ANTIC program, or short the <i>Display
List.</i> This is useful for getting an idea how the screen
is generated. The <b>S</b> extender prints the contents of
the ANTIC register set, for example to find the start
address of the display list. Finally, the <b>V</b> extender
sets the number of lines the ANTIC disassembler prints in
one go.</p>

<p style="margin-left:11%;">UNAS=U [expr]; extenders:
L,V</p>

<p style="margin-left:22%;">This is the 6502 disassembler.
The <b>L</b> extender does exactly this; it disassembles at
the address given by its argument. The disassembler knows
all &ldquo;extra instructions&rdquo; of the 6502 and prints
them as four character rather than three character
opcodes.</p>

<p style="margin-left:22%; margin-top: 1em">If a ca65 debug
file has been (see <b>ENVI.S</b> below), then the
disassembler automatically substitutes numeric values with
the constants, labels and equates recorded in the debug
file.</p>

<p style="margin-left:22%; margin-top: 1em">The <b>V</b>
extender sets the number of lines the disassembler prints at
a time.</p>

<p style="margin-left:11%;">RSET=P; extenders: W,C,I</p>

<p style="margin-left:22%;">Various reset commands. The
<b>W</b> extender warm-starts the emulator, the <b>C</b>
extender runs into a coldstart. Both instructions also leave
the monitor as its full working environment is reset as
well. If you need to debug instructions directly following
the cold-start sequence, consider using the <i>-traceonreset
on</i> command line switch.</p>

<p style="margin-left:22%; margin-top: 1em">Note that the
warm-reset really holds the reset signal of the CPU. This is
unlike the <b>Reset Console Key</b> on the Atari 800 and 400
models work; they just raise a special Antic NMI signal and
leave it to the Os to detect this signal and jump to the
reset vector. This kind of reset is reached with the
<b>I</b> extender, though note that the detection of this
NMI interrupt has been removed in Os ROM of the XL and XE
models.</p>

<p style="margin-left:11%;">EXIT=X; no extenders</p>

<p style="margin-left:22%;">Takes no arguments and no
extenders and leaves the emulator immediately.</p>

<p style="margin-left:11%;">GOPG=G; extenders: P,U,M</p>

<p style="margin-left:22%;">Takes no arguments and
re-starts the emulation at the current program counter value
for the <b>P</b> extender. Hence, this leaves the monitor
and continues emulation. For the <b>M</b> extender, the
emulation also continues, but the configuration menu is
entered as soon as possible after leaving the monitor, as if
<i>F1</i> has been pressed. This may take as long as a
vertical retrace of the emulated screen, and some code might
have been run when the menu is entered. The <i>U</i>
extender, finally, runs the program until the stack pointer
gets larger than its current value. This is useful to
terminate a current subroutine call and to return to the
calling function immediately.</p>

<p style="margin-left:11%;">STEP=Z; extenders: S,I</p>

<p style="margin-left:22%;">Single step thru a program. If
used with the <b>S</b> extender, the simple interface is
used and similar to the <b>GOPG</b> command, the program is
run, but the monitor is re-entered immediately after
execution of the command under the PC, printing the command
that was executed last. This is most useful for debugging
purposes and single-stepping thru critical sections of a
program.</p>

<p style="margin-left:22%; margin-top: 1em">If the <b>I</b>
extender is selected, a full-screen graphical debugger is
entered provided the curses library was available at compile
time. If so, a full screen of disassembled code is printed
and the monitor waits for further commands. The <b>Z</b> key
single steps then, the <b>N</b> key works similar to the
<b>NEXT</b> command (see below) and steps over subroutines
and loops, the <b>G</b> key re-starts the program and leaves
the monitor, the <b>B</b> key sets a break point at the
current program location and, finally, the <b>U</b> command
runs the emulated CPU until the stack pointer is increased,
thus usually up to the end of the current sub-program.</p>

<p style="margin-left:11%;">NEXT=N; no extenders</p>

<p style="margin-left:22%;">Similar to <b>STEP</b> though
this command does not step into subroutines. For any
operation that places data onto the hardware stack, this
command will run the program up to the location where the
data is again popped from the stack; if the current
instruction is not a <i>JSR</i> instruction, then the
emulator is run until the program counter of the emulated
CPU gets larger than its current value. This is for example
useful to complete a larger loop with a backwards branch at
its end by just one monitor command.</p>

<p style="margin-left:11%;">STAT=T [comp]; extenders:
L,S</p>

<p style="margin-left:22%;">Prints status information about
various system components, including internal hardware
register sets, port settings and configuration. The <b>L</b>
extender lists all system components for which a status
information is available, and <b>STAT.S</b> followed by the
name of this component prints the status of the mentioned
component.</p>

<p style="margin-left:11%;">SETR=S register=expr; no
extenders</p>

<p style="margin-left:22%;">Sets a CPU register to a
specified value given by an expression. The syntax of this
command is non-standard for convenience reasons. Register
and desired register contents are separated by an equals
sign, and not by a blank. For example, <b>SETR A=ff</b>
would set the contents of the accumulator to 255=0xff.</p>

<p style="margin-left:11%;">REGS=R; no extenders</p>

<p style="margin-left:22%;">displays the contents of the
CPU in a brief listing. This command is ideal for the
<b>SPLT</b> command explained next.</p>

<p style="margin-left:11%;">SPLT=/ [cmds]; extenders:
C,S</p>

<p style="margin-left:22%;">This command is special as it
modifies the behaviour of the monitor and does not perform a
direct action on the emulation components. The <b>S</b>
extender splits off the top part of the monitor output
window and prints there the contents of the commands
following the SPLT command. For example, <b>SPLT.S R</b>
would continously display the register dump of the 6502 CPU
on top of the screen.</p>

<p style="margin-left:22%; margin-top: 1em">Several
commands can be run at once by separating them with a colon.
The split-off output is updated on each command, making the
screen splitting an ideal feature for the single stepping
and debugging. The <b>C</b> extender cleans and removes this
split-off part of the screen again.</p>

<p style="margin-left:11%;">ENVI=V [value]; extenders:
A,L,S,C</p>

<p style="margin-left:22%;">Controls various (currently
one) monitor environment settings. The <b>A</b> extender
controls the view on the memory. As the 130XE offers 128K of
memory that can be selectively banked for the CPU and for
ANTIC, it matters whether the memory is seen by the CPU or
by ANTIC as both may have selected different banks for it.
This environment switch toggles the view of the monitor onto
the memory as either comming from ANTIC or from the CPU.</p>

<p style="margin-left:22%; margin-top: 1em"><b>L</b> This
extender expects a file name as argument. The status of the
emulated CPU is then logged into the file, including the
register set and the timing information, i.e. horizontal and
vertical beam position. Note that this file may grow very
fast and becomes huge shortly. To disable logging, supply an
empty file name.</p>

<p style="margin-left:22%; margin-top: 1em"><b>S</b> This
extender loads a debug file into the monitor, which defines
labels, equates and constants. This information is used by
the disassembler and the expression evaluator; the former
substitutes numerical values by their label names and hence
makes the output of the disassembler more readable, the
latter also accepts labels and equates as input and replaces
them by their value. This environment setting accepts files
in the &ldquo;debugfile&rdquo; format generated by the
<b>ca65</b> assembler. They are created with the
<b>--dbgfile</b> command line option of the assembler. The
<b>ENVI.S</b> command takes a single argument, namely the
file name of the debug file to be parsed. Information in
this file is then added to the internal label database of
the monitor.</p>

<p style="margin-left:22%; margin-top: 1em"><b>C</b> This
extender clears the internal label database, i.e. it forgets
all label, equate and constant names that have been defined
by a <b>ENVI.S</b> command before.</p>

<p style="margin-left:11%;">PROF=O; extenders: S,L,C,X</p>

<p style="margin-left:22%;">This monitor command controls
the built-in profiler, allowing you to find performance
bottlenecks in machine language programs running on the
emulated 6502. The <b>S</b> extender starts recording
profile information. After issuing this command, return to
the emulator with <b>GOPG</b> and start and/or continue
execution of the program you want to profile. Re-enter the
monitor any time you want to access the collected profile
data.</p>

<p style="margin-left:22%; margin-top: 1em"><b>L</b> lists
the execution counts per memory, sorted in descending order.
The first column of the profiler output lists the memory
location, in hex or symbolic form, at which the profiled
instruction was recorded. The next column shows the absolute
count how often that location was accessed. The last column
lists the percentage of how often the listed instruction has
been executed compared to the overall instruction count
collected by the profiler. If several consecutive
instructions have exactly the same hit-count, these
instructions are not listed separately, only the first
instruction of the instruction block is shown. Note that
this command extender lists instruction hit counts, i.e. it
performs a coverage analysis, and not a cycle count
analysis.</p>

<p style="margin-left:22%; margin-top: 1em"><b>C</b> lists
the cumulative execution time of subroutines in cycles,
listed in descending frequencies. Unlike the output of the
<b>L</b> extender, this list shows the total number of
cycles the CPU required to execute a subroutine, together
with all the children it called. It sorts the output by
cycle count, with the function taking the longest time on
top. This is typically the main program. The percentage of
time the code spend in a subroutine is also shown.</p>

<p style="margin-left:22%; margin-top: 1em"><b>X</b> This
extender stops the profiler and clears the profiler
database.</p>

<h2>FILES
<a name="FILES"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em">/etc/atari++/atari++.conf</p>

<p style="margin-left:22%;">The system global configuration
files</p>

<p style="margin-left:11%;">~/.atari++.conf</p>

<p style="margin-left:22%;">The user specific configuration
file</p>

<p style="margin-left:11%;">./.atari++.conf</p>

<p style="margin-left:22%;">The directory specific
configuration file.</p>

<h2>ENVIRONMENT VARIABLES
<a name="ENVIRONMENT VARIABLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">No emulator
specific variables. Atari++ is controlled completely by its
configuration files and command line arguments.</p>

<h2>CREDITS
<a name="CREDITS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">David Firth for
his Atari800 emulator. Atari++ is not based on this earlier
work, though influenced. Atari++ was entirely and completely
rewritten from scratch, in C++, avoiding some of the
constructional difficulties of David&rsquo;s work.
Especially, the way how graphics output is constructed and
how player/missile graphic priorities are generated is quite
different from his implementation.</p>

<p style="margin-left:11%; margin-top: 1em">Ron Fries for
the Pokey emulation routine that got used in early releases
of the Atari800 emulator. The strategy that has been
utilized for sound build-up has been used in the pokey
emulation of this emulator as well, though the
implementation details are a bit different and the overall
quality of the sound emulation has been improved heavily.
Specifically, high-pass filters, sound muting and
anti-aliasing are new to the emulation model.</p>

<p style="margin-left:11%; margin-top: 1em">Jean-loup
Gailly and Mark Adler for the Z compression library that
gets used if available for .gz compressed disk images.</p>

<p style="margin-left:11%; margin-top: 1em">Sam Lantinga
and the SDL group for the Simple DirectMedia Layer library,
or short, SDL, that offers one of the possible front-ends of
the Atari++ emulator if it is available.</p>

<p style="margin-left:11%; margin-top: 1em">Jindroush and
the Atari Cartridge Dumping project for providing insight
into the details of the cart emulation. Specifically, SDX
and XEGS cart emulation would have been impossible without
him.</p>

<p style="margin-left:11%; margin-top: 1em">Petr Stehlik
and the remaining atari800 team for cooperation and for
working out the licencing conditions of this emulator.
Specifically, I thank Petr for keeping cool in the hot days
of working out all the details of making this project
available.</p>

<p style="margin-left:11%; margin-top: 1em">Andreas
Magenheimer and the ABBUC team for providing some hardware
insight that was otherwise not available. Specifically,
emulation of various bank switching logics is due to
ABBUC.</p>

<p style="margin-left:11%; margin-top: 1em">Jason
Duerstock&rsquo;s for its analyzation of the RT8 cartridge.
Unfortunately, something seems to be still not quite right
with it. The current implementation in Atari++ uses a
somewhat different route how the register assignment might
work. This is all an educated guess, though.</p>

<p style="margin-left:11%; margin-top: 1em">B. Watson for
keeping pushing me to re-implement the math-pack; it&rsquo;s
been done, now, providing a full free implementation of the
Atari operating system.</p>

<p style="margin-left:11%; margin-top: 1em">Konrad
Kokoszkiewicz for finding and fixing many bugs in the
emulation of floppy disks. Part of the &quot;speedy&quot;
comments were broken or potentially mis-interpreted, and
floppy sizes weren&rsquo;t detected and supported correctly
under all circumstances. Thanks, folks!</p>

<p style="margin-left:11%; margin-top: 1em">Ralph
&quot;pps&quot; for redesigning the Atari++ home page and
hosting the whole project. Unfortunately, my employer can no
longer host it when I moved.</p>


<p style="margin-left:11%; margin-top: 1em">&quot;Phaeron&quot;
for documenting many undocumented chipset and CPU features
and for answering all my questions. Many of the improvements
made in release 1.70 are due to his work.</p>

<h2>REFERENCES
<a name="REFERENCES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">DE RE ATARI</p>

<p style="margin-left:22%;">by John Eckstrom, Michael A.
Eckberg, Gus Makreas, Lane Winner and Elizabeth
Hernaton.</p>

<p style="margin-left:11%;">Das Atari Profibuch</p>

<p style="margin-left:22%;">by Julian Reschke and Andreas
Wiethoff, Sybex, 1985.</p>

<p style="margin-left:11%;">6502 Assembly Language
Programming</p>

<p style="margin-left:22%;">by Lance A. Leventhal,
McGraw-Hill, 1979.</p>

<p style="margin-left:11%;">Atari Technical
Documentation</p>

<p style="margin-left:22%;">from <i>The Atari Historical
Society</i> at www.atari-history.com</p>

<p style="margin-left:11%;">Your Atari Computer</p>

<p style="margin-left:22%;">by Lon Pool, Martin McNiff
&amp; Steven Cook, McGraw-Hill, 1982. German translation
&ldquo;Mein Atari Computer&rdquo; by te-wi, 1983.</p>

<h2>AUTHOR
<a name="AUTHOR"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">Thomas Richter
(thor@math.tu-berlin.de)</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">An
Atari800.</p>
<hr>
</body>
</html>
